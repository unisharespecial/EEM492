CCS PCM C Compiler, Version 4.106, 18916               02-Oca-14 17:39

               Filename: C:\Users\AKIN\Desktop\bitirme-proje\Sadik_carsamba\dden7.lst

               ROM used: 897 words (11%)
                         Largest free fragment is 2048
               RAM used: 17 (5%) at main() level
                         33 (9%) worst case
               Stack:    4 locations

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   2CA
0003:  NOP
.................... #include "C:\Users\AKIN\Desktop\bitirme-proje\Sadik_carsamba\dden7.h" 
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES HS                    	//High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOWRT                 	//Program memory not write protected 
....................  
.................... #use delay(clock=20000000) 
....................  
....................  
.................... #use delay(clock=20M) 
*
002C:  MOVLW  33
002D:  MOVWF  04
002E:  BCF    03.7
002F:  MOVF   00,W
0030:  BTFSC  03.2
0031:  GOTO   03F
0032:  MOVLW  06
0033:  MOVWF  78
0034:  CLRF   77
0035:  DECFSZ 77,F
0036:  GOTO   035
0037:  DECFSZ 78,F
0038:  GOTO   034
0039:  MOVLW  7B
003A:  MOVWF  77
003B:  DECFSZ 77,F
003C:  GOTO   03B
003D:  DECFSZ 00,F
003E:  GOTO   032
003F:  RETURN
.................... #fuses HS,NOWDT,NOPROTECT 
.................... #define dht11 PIN_B0 
.................... #include "flex_lcd.c" 
.................... // flex_lcd.c  
....................  
.................... // These pins are for the Microchip PicDem2-Plus board,  
.................... // which is what I used to test the driver.  Change these  
.................... // pins to fit your own board.  
....................  
.................... #define LCD_DB4   PIN_D0  
.................... #define LCD_DB5   PIN_D1  
.................... #define LCD_DB6   PIN_D2  
.................... #define LCD_DB7   PIN_D3  
....................  
.................... #define LCD_E     PIN_A1  
.................... #define LCD_RS    PIN_A3  
.................... #define LCD_RW    PIN_A2  
....................  
.................... // If you only want a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  
....................  
.................... #define USE_LCD_RW   1       
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................  0xc,                    // Display on  
....................  1,                      // Clear display  
....................  6                       // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
0040:  BTFSC  3A.0
0041:  GOTO   044
0042:  BCF    08.0
0043:  GOTO   045
0044:  BSF    08.0
0045:  BSF    03.5
0046:  BCF    08.0
....................  output_bit(LCD_DB5, !!(nibble & 2));   
0047:  BCF    03.5
0048:  BTFSC  3A.1
0049:  GOTO   04C
004A:  BCF    08.1
004B:  GOTO   04D
004C:  BSF    08.1
004D:  BSF    03.5
004E:  BCF    08.1
....................  output_bit(LCD_DB6, !!(nibble & 4));     
004F:  BCF    03.5
0050:  BTFSC  3A.2
0051:  GOTO   054
0052:  BCF    08.2
0053:  GOTO   055
0054:  BSF    08.2
0055:  BSF    03.5
0056:  BCF    08.2
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0057:  BCF    03.5
0058:  BTFSC  3A.3
0059:  GOTO   05C
005A:  BCF    08.3
005B:  GOTO   05D
005C:  BSF    08.3
005D:  BSF    03.5
005E:  BCF    08.3
....................  
....................  delay_cycles(1);  
005F:  NOP
....................  output_high(LCD_E);  
0060:  BCF    05.1
0061:  BCF    03.5
0062:  BSF    05.1
....................  delay_us(2);  
0063:  MOVLW  03
0064:  MOVWF  77
0065:  DECFSZ 77,F
0066:  GOTO   065
....................  output_low(LCD_E);  
0067:  BSF    03.5
0068:  BCF    05.1
0069:  BCF    03.5
006A:  BCF    05.1
.................... }  
006B:  RETURN
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
006C:  CLRF   3B
....................      
.................... output_high(LCD_E);  
006D:  BSF    03.5
006E:  BCF    05.1
006F:  BCF    03.5
0070:  BSF    05.1
.................... delay_cycles(1);  
0071:  NOP
....................  
.................... retval_0 = input(LCD_DB4);  
0072:  BSF    03.5
0073:  BSF    08.0
0074:  BCF    03.5
0075:  BCF    3B.0
0076:  BTFSC  08.0
0077:  BSF    3B.0
.................... retval_1 = input(LCD_DB5);  
0078:  BSF    03.5
0079:  BSF    08.1
007A:  BCF    03.5
007B:  BCF    3B.1
007C:  BTFSC  08.1
007D:  BSF    3B.1
.................... retval_2 = input(LCD_DB6);  
007E:  BSF    03.5
007F:  BSF    08.2
0080:  BCF    03.5
0081:  BCF    3B.2
0082:  BTFSC  08.2
0083:  BSF    3B.2
.................... retval_3 = input(LCD_DB7);  
0084:  BSF    03.5
0085:  BSF    08.3
0086:  BCF    03.5
0087:  BCF    3B.3
0088:  BTFSC  08.3
0089:  BSF    3B.3
....................    
.................... output_low(LCD_E);  
008A:  BSF    03.5
008B:  BCF    05.1
008C:  BCF    03.5
008D:  BCF    05.1
....................      
.................... return(retval);     
008E:  MOVF   3B,W
008F:  MOVWF  78
.................... }     
0090:  RETURN
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
*
0095:  BSF    03.5
0096:  BCF    05.2
0097:  BCF    03.5
0098:  BSF    05.2
.................... delay_cycles(1);  
0099:  NOP
....................  
.................... high = lcd_read_nibble();  
009A:  CALL   06C
009B:  MOVF   78,W
009C:  MOVWF  3A
....................  
.................... low = lcd_read_nibble();  
009D:  CALL   06C
009E:  MOVF   78,W
009F:  MOVWF  39
....................  
.................... return( (high<<4) | low);  
00A0:  SWAPF  3A,W
00A1:  MOVWF  77
00A2:  MOVLW  F0
00A3:  ANDWF  77,F
00A4:  MOVF   77,W
00A5:  IORWF  39,W
00A6:  MOVWF  78
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
*
0091:  BSF    03.5
0092:  BCF    05.3
0093:  BCF    03.5
0094:  BCF    05.3
....................  
.................... #ifdef USE_LCD_RW  
.................... while(bit_test(lcd_read_byte(),7)) ;  
*
00A7:  MOVF   78,W
00A8:  MOVWF  39
00A9:  BTFSC  39.7
00AA:  GOTO   095
.................... #else  
.................... delay_us(60);   
.................... #endif  
....................  
.................... if(address)  
00AB:  MOVF   37,F
00AC:  BTFSC  03.2
00AD:  GOTO   0B3
....................    output_high(LCD_RS);  
00AE:  BSF    03.5
00AF:  BCF    05.3
00B0:  BCF    03.5
00B1:  BSF    05.3
.................... else  
00B2:  GOTO   0B7
....................    output_low(LCD_RS);  
00B3:  BSF    03.5
00B4:  BCF    05.3
00B5:  BCF    03.5
00B6:  BCF    05.3
....................        
....................  delay_cycles(1);  
00B7:  NOP
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
00B8:  BSF    03.5
00B9:  BCF    05.2
00BA:  BCF    03.5
00BB:  BCF    05.2
.................... delay_cycles(1);  
00BC:  NOP
.................... #endif  
....................  
.................... output_low(LCD_E);  
00BD:  BSF    03.5
00BE:  BCF    05.1
00BF:  BCF    03.5
00C0:  BCF    05.1
....................  
.................... lcd_send_nibble(n >> 4);  
00C1:  SWAPF  38,W
00C2:  MOVWF  39
00C3:  MOVLW  0F
00C4:  ANDWF  39,F
00C5:  MOVF   39,W
00C6:  MOVWF  3A
00C7:  CALL   040
.................... lcd_send_nibble(n & 0xf);  
00C8:  MOVF   38,W
00C9:  ANDLW  0F
00CA:  MOVWF  39
00CB:  MOVWF  3A
00CC:  CALL   040
.................... }  
00CD:  RETURN
....................  
.................... //----------------------------  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... output_low(LCD_RS);  
00CE:  BSF    03.5
00CF:  BCF    05.3
00D0:  BCF    03.5
00D1:  BCF    05.3
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
00D2:  BSF    03.5
00D3:  BCF    05.2
00D4:  BCF    03.5
00D5:  BCF    05.2
.................... #endif  
....................  
.................... output_low(LCD_E);  
00D6:  BSF    03.5
00D7:  BCF    05.1
00D8:  BCF    03.5
00D9:  BCF    05.1
....................  
.................... delay_ms(15);  
00DA:  MOVLW  0F
00DB:  MOVWF  33
00DC:  CALL   02C
....................  
.................... for(i=0 ;i < 3; i++)  
00DD:  CLRF   2C
00DE:  MOVF   2C,W
00DF:  SUBLW  02
00E0:  BTFSS  03.0
00E1:  GOTO   0EA
....................    {  
....................     lcd_send_nibble(0x03);  
00E2:  MOVLW  03
00E3:  MOVWF  3A
00E4:  CALL   040
....................     delay_ms(5);  
00E5:  MOVLW  05
00E6:  MOVWF  33
00E7:  CALL   02C
....................    }  
00E8:  INCF   2C,F
00E9:  GOTO   0DE
....................  
.................... lcd_send_nibble(0x02);  
00EA:  MOVLW  02
00EB:  MOVWF  3A
00EC:  CALL   040
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
00ED:  CLRF   2C
00EE:  MOVF   2C,W
00EF:  SUBLW  03
00F0:  BTFSS  03.0
00F1:  GOTO   0FB
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
00F2:  MOVF   2C,W
00F3:  CALL   004
00F4:  MOVWF  2D
00F5:  CLRF   37
00F6:  MOVF   2D,W
00F7:  MOVWF  38
00F8:  CALL   091
....................      
....................     // If the R/W signal is not used, then  
....................     // the busy bit can't be polled.  One of  
....................     // the init commands takes longer than  
....................     // the hard-coded delay of 60 us, so in  
....................     // that case, lets just do a 5 ms delay  
....................     // after all four of them.  
....................     #ifndef USE_LCD_RW  
....................     delay_ms(5);  
....................     #endif  
....................    }  
00F9:  INCF   2C,F
00FA:  GOTO   0EE
....................  
.................... }  
00FB:  BCF    0A.3
00FC:  BCF    0A.4
00FD:  GOTO   319 (RETURN)
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
.................... if(y != 1)  
*
019B:  DECFSZ 34,W
019C:  GOTO   19E
019D:  GOTO   1A1
....................    address = lcd_line_two;  
019E:  MOVLW  40
019F:  MOVWF  35
.................... else  
01A0:  GOTO   1A2
....................    address=0;  
01A1:  CLRF   35
....................  
.................... address += x-1;  
01A2:  MOVLW  01
01A3:  SUBWF  33,W
01A4:  ADDWF  35,F
.................... lcd_send_byte(0, 0x80 | address);  
01A5:  MOVF   35,W
01A6:  IORLW  80
01A7:  MOVWF  36
01A8:  CLRF   37
01A9:  MOVF   36,W
01AA:  MOVWF  38
01AB:  CALL   091
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
....................    {  
*
0184:  MOVF   32,W
0185:  XORLW  0C
0186:  BTFSC  03.2
0187:  GOTO   18F
0188:  XORLW  06
0189:  BTFSC  03.2
018A:  GOTO   197
018B:  XORLW  02
018C:  BTFSC  03.2
018D:  GOTO   1AD
018E:  GOTO   1B2
....................     case '\f':  
....................       lcd_send_byte(0,1);  
018F:  CLRF   37
0190:  MOVLW  01
0191:  MOVWF  38
0192:  CALL   091
....................       delay_ms(2);  
0193:  MOVLW  02
0194:  MOVWF  33
0195:  CALL   02C
....................       break;  
0196:  GOTO   1B8
....................      
....................     case '\n':  
....................        lcd_gotoxy(1,2);  
0197:  MOVLW  01
0198:  MOVWF  33
0199:  MOVLW  02
019A:  MOVWF  34
....................        break;  
*
01AC:  GOTO   1B8
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
01AD:  CLRF   37
01AE:  MOVLW  10
01AF:  MOVWF  38
01B0:  CALL   091
....................        break;  
01B1:  GOTO   1B8
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
01B2:  MOVLW  01
01B3:  MOVWF  37
01B4:  MOVF   32,W
01B5:  MOVWF  38
01B6:  CALL   091
....................        break;  
01B7:  GOTO   1B8
....................    }  
.................... }  
01B8:  RETURN
....................  
.................... //------------------------------  
.................... #ifdef USE_LCD_RW  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(lcd_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
....................  
.................... char dht_dat[10]; // Output data will be here 
....................  
.................... void dht_init() 
....................  
.................... { 
....................     delay_ms (1); 
*
00FE:  MOVLW  01
00FF:  MOVWF  33
0100:  CALL   02C
....................     output_high(dht11); 
0101:  BSF    03.5
0102:  BCF    06.0
0103:  BCF    03.5
0104:  BSF    06.0
.................... } 
0105:  RETURN
.................... int leer_dht_dat() 
....................  
.................... { 
*
0147:  CLRF   32
0148:  CLRF   33
....................     int i = 0; 
....................     int result = 0; 
....................  
....................     for (i = 0; i < 8; i++) 
0149:  CLRF   32
014A:  MOVF   32,W
014B:  SUBLW  07
014C:  BTFSS  03.0
014D:  GOTO   172
....................     { 
....................         while (input (dht11) == 0); 
014E:  BSF    03.5
014F:  BSF    06.0
0150:  BCF    03.5
0151:  BTFSS  06.0
0152:  GOTO   14E
....................  
....................         delay_us(30); 
0153:  MOVLW  31
0154:  MOVWF  77
0155:  DECFSZ 77,F
0156:  GOTO   155
0157:  GOTO   158
....................  
....................         if (input (dht11) == 1) 
0158:  BSF    03.5
0159:  BSF    06.0
015A:  BCF    03.5
015B:  BTFSS  06.0
015C:  GOTO   16B
....................         { 
....................             result |= (1 << (7 - i) ); 
015D:  MOVF   32,W
015E:  SUBLW  07
015F:  MOVWF  78
0160:  MOVLW  01
0161:  MOVWF  77
0162:  MOVF   78,F
0163:  BTFSC  03.2
0164:  GOTO   169
0165:  BCF    03.0
0166:  RLF    77,F
0167:  DECFSZ 78,F
0168:  GOTO   165
0169:  MOVF   77,W
016A:  IORWF  33,F
....................         } 
....................  
....................         while (input (dht11) == 1); 
016B:  BSF    03.5
016C:  BSF    06.0
016D:  BCF    03.5
016E:  BTFSC  06.0
016F:  GOTO   16B
....................     } 
0170:  INCF   32,F
0171:  GOTO   14A
....................  
....................     return result; 
0172:  MOVF   33,W
0173:  MOVWF  78
.................... } 
....................  
.................... void read_dht() 
.................... { 
*
0106:  CLRF   2C
....................     int GlobalErr = 0; 
....................     int dht_in; 
....................     int i; 
....................     int dht_check_sum; 
....................     dht_init(); 
0107:  CALL   0FE
....................     output_low(dht11); 
0108:  BSF    03.5
0109:  BCF    06.0
010A:  BCF    03.5
010B:  BCF    06.0
....................     delay_ms(18); 
010C:  MOVLW  12
010D:  MOVWF  33
010E:  CALL   02C
....................     output_high(dht11); 
010F:  BSF    03.5
0110:  BCF    06.0
0111:  BCF    03.5
0112:  BSF    06.0
....................     delay_us(30); 
0113:  MOVLW  31
0114:  MOVWF  77
0115:  DECFSZ 77,F
0116:  GOTO   115
0117:  GOTO   118
....................     dht_in = input(dht11); 
0118:  BSF    03.5
0119:  BSF    06.0
011A:  BCF    03.5
011B:  CLRF   2D
011C:  BTFSC  06.0
011D:  INCF   2D,F
....................  
....................     if (dht_in) 
011E:  MOVF   2D,F
011F:  BTFSC  03.2
0120:  GOTO   124
....................     { 
....................         GlobalErr = 1; 
0121:  MOVLW  01
0122:  MOVWF  2C
....................         return; 
0123:  GOTO   181
....................     } 
....................  
....................     delay_us(80); 
0124:  MOVLW  85
0125:  MOVWF  77
0126:  DECFSZ 77,F
0127:  GOTO   126
....................     dht_in = input(dht11); 
0128:  BSF    03.5
0129:  BSF    06.0
012A:  BCF    03.5
012B:  CLRF   2D
012C:  BTFSC  06.0
012D:  INCF   2D,F
....................  
....................     if (!dht_in) 
012E:  MOVF   2D,F
012F:  BTFSS  03.2
0130:  GOTO   134
....................     { 
....................         GlobalErr = 2; 
0131:  MOVLW  02
0132:  MOVWF  2C
....................         return; 
0133:  GOTO   181
....................     } 
....................  
....................     delay_us(80); 
0134:  MOVLW  85
0135:  MOVWF  77
0136:  DECFSZ 77,F
0137:  GOTO   136
....................  
....................     for (i = 0; i < 4; i++) 
0138:  CLRF   2E
0139:  MOVF   2E,W
013A:  SUBLW  03
013B:  BTFSS  03.0
013C:  GOTO   17D
....................     { 
....................         dht_dat[i] = leer_dht_dat(); 
013D:  MOVLW  20
013E:  ADDWF  2E,W
013F:  MOVWF  78
0140:  CLRF   7A
0141:  BTFSC  03.0
0142:  INCF   7A,F
0143:  MOVF   78,W
0144:  MOVWF  30
0145:  MOVF   7A,W
0146:  MOVWF  31
*
0174:  MOVF   30,W
0175:  MOVWF  04
0176:  BCF    03.7
0177:  BTFSC  31.0
0178:  BSF    03.7
0179:  MOVF   78,W
017A:  MOVWF  00
....................     } 
017B:  INCF   2E,F
017C:  GOTO   139
....................  
....................     output_high(dht11); 
017D:  BSF    03.5
017E:  BCF    06.0
017F:  BCF    03.5
0180:  BSF    06.0
.................... } 
0181:  BCF    0A.3
0182:  BCF    0A.4
0183:  GOTO   31E (RETURN)
....................  
....................  
....................  
....................  
.................... void main() 
.................... { 
*
002B:  DATA 00,00
*
02CA:  CLRF   04
02CB:  BCF    03.7
02CC:  MOVLW  1F
02CD:  ANDWF  03,F
02CE:  BSF    03.5
02CF:  BSF    1F.0
02D0:  BSF    1F.1
02D1:  BSF    1F.2
02D2:  BCF    1F.3
02D3:  MOVLW  07
02D4:  MOVWF  1C
....................  
....................    setup_adc_ports(NO_ANALOGS); 
*
02D8:  BSF    03.5
02D9:  BSF    1F.0
02DA:  BSF    1F.1
02DB:  BSF    1F.2
02DC:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_2); 
02DD:  BCF    1F.6
02DE:  BCF    03.5
02DF:  BCF    1F.6
02E0:  BCF    1F.7
02E1:  BSF    03.5
02E2:  BCF    1F.7
02E3:  BCF    03.5
02E4:  BSF    1F.0
....................    setup_psp(PSP_DISABLED); 
02E5:  BSF    03.5
02E6:  BCF    09.4
....................    setup_spi(SPI_SS_DISABLED); 
02E7:  BCF    03.5
02E8:  BCF    14.5
02E9:  BCF    2A.5
02EA:  MOVF   2A,W
02EB:  BSF    03.5
02EC:  MOVWF  07
02ED:  BCF    03.5
02EE:  BSF    2A.4
02EF:  MOVF   2A,W
02F0:  BSF    03.5
02F1:  MOVWF  07
02F2:  BCF    03.5
02F3:  BCF    2A.3
02F4:  MOVF   2A,W
02F5:  BSF    03.5
02F6:  MOVWF  07
02F7:  MOVLW  01
02F8:  BCF    03.5
02F9:  MOVWF  14
02FA:  MOVLW  00
02FB:  BSF    03.5
02FC:  MOVWF  14
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
02FD:  MOVF   01,W
02FE:  ANDLW  C7
02FF:  IORLW  08
0300:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
0301:  BCF    03.5
0302:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0303:  MOVLW  00
0304:  MOVWF  78
0305:  MOVWF  12
0306:  MOVLW  00
0307:  BSF    03.5
0308:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
0309:  MOVLW  07
030A:  MOVWF  1C
030B:  MOVF   05,W
030C:  MOVWF  05
030D:  MOVLW  10
030E:  MOVWF  77
030F:  DECFSZ 77,F
0310:  GOTO   30F
0311:  NOP
0312:  MOVF   1C,W
0313:  BCF    03.5
0314:  BCF    0D.6
....................    setup_vref(FALSE); 
0315:  BSF    03.5
0316:  CLRF   1D
....................    lcd_init(); 
0317:  BCF    03.5
0318:  GOTO   0CE
....................    delay_ms(100); 
0319:  MOVLW  64
031A:  MOVWF  33
031B:  CALL   02C
....................    dht_init(); 
031C:  CALL   0FE
....................    int dht11_check_sum; 
....................    while(1) 
....................    { 
....................       read_dht(); // Check dht_dat variable after this funciton 
031D:  GOTO   106
....................       dht11_check_sum = (dht_dat[0]+dht_dat[1]+dht_dat[2]+dht_dat[3]) & 0xFF;// check check_sum 
031E:  MOVF   21,W
031F:  ADDWF  20,W
0320:  ADDWF  22,W
0321:  ADDWF  23,W
0322:  MOVWF  2B
....................       if(dht_dat[4]!= dht11_check_sum) 
0323:  MOVF   2B,W
0324:  SUBWF  24,W
0325:  BTFSC  03.2
0326:  GOTO   32F
....................       { 
....................          printf(lcd_putc, "DHT11 checksum error"); 
0327:  MOVLW  0C
0328:  BSF    03.6
0329:  MOVWF  0D
032A:  MOVLW  00
032B:  MOVWF  0F
032C:  BCF    03.6
032D:  GOTO   1B9
....................       } 
....................       else 
032E:  GOTO   378
....................       { 
....................          printf(lcd_putc,"\fHUMI RH :%d.%d %%  ",dht_dat[0],dht_dat[1]); 
032F:  MOVLW  17
0330:  BSF    03.6
0331:  MOVWF  0D
0332:  MOVLW  00
0333:  MOVWF  0F
0334:  BCF    03.0
0335:  MOVLW  0A
0336:  BCF    03.6
0337:  MOVWF  2C
0338:  CALL   201
0339:  MOVF   20,W
033A:  MOVWF  2C
033B:  MOVLW  1F
033C:  MOVWF  2D
033D:  CALL   265
033E:  MOVLW  2E
033F:  MOVWF  32
0340:  CALL   184
0341:  MOVF   21,W
0342:  MOVWF  2C
0343:  MOVLW  1F
0344:  MOVWF  2D
0345:  CALL   265
0346:  MOVLW  20
0347:  MOVWF  32
0348:  CALL   184
0349:  MOVLW  25
034A:  MOVWF  32
034B:  CALL   184
034C:  MOVLW  20
034D:  MOVWF  32
034E:  CALL   184
034F:  MOVLW  20
0350:  MOVWF  32
0351:  CALL   184
....................          printf(lcd_putc,"\nTEMP :%d.%d %cC  ",dht_dat[2],dht_dat[3],223); 
0352:  MOVLW  22
0353:  BSF    03.6
0354:  MOVWF  0D
0355:  MOVLW  00
0356:  MOVWF  0F
0357:  BCF    03.0
0358:  MOVLW  07
0359:  BCF    03.6
035A:  MOVWF  2C
035B:  CALL   201
035C:  MOVF   22,W
035D:  MOVWF  2C
035E:  MOVLW  1F
035F:  MOVWF  2D
0360:  CALL   265
0361:  MOVLW  2E
0362:  MOVWF  32
0363:  CALL   184
0364:  MOVF   23,W
0365:  MOVWF  2C
0366:  MOVLW  1F
0367:  MOVWF  2D
0368:  CALL   265
0369:  MOVLW  20
036A:  MOVWF  32
036B:  CALL   184
036C:  MOVLW  DF
036D:  MOVWF  32
036E:  CALL   184
036F:  MOVLW  43
0370:  MOVWF  32
0371:  CALL   184
0372:  MOVLW  20
0373:  MOVWF  32
0374:  CALL   184
0375:  MOVLW  20
0376:  MOVWF  32
0377:  CALL   184
....................       } 
....................       delay_ms(2000); 
0378:  MOVLW  08
0379:  MOVWF  2C
037A:  MOVLW  FA
037B:  MOVWF  33
037C:  CALL   02C
037D:  DECFSZ 2C,F
037E:  GOTO   37A
....................    } 
037F:  GOTO   31D
....................  
.................... } 
....................  
....................  
....................  
0380:  SLEEP

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
