CCS PCH C Compiler, Version 4.106, 18916               10-Oca-14 17:02

               Filename: C:\Users\AKIN\Desktop\nem\nem.lst

               ROM used: 3280 bytes (10%)
                         Largest free fragment is 29488
               RAM used: 20 (1%) at main() level
                         80 (5%) worst case
               Stack:    5 locations

*
0000:  GOTO   0934
.................... #include <18F452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES XT                       //Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOOSCSEN                 //Oscillator switching is disabled, main oscillator is source 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOSTVREN                 //Stack full/underflow will not cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(clock=4000000) 
*
0038:  CLRF   FEA
003A:  MOVLW  22
003C:  MOVWF  FE9
003E:  MOVF   FEF,W
0040:  BZ    005E
0042:  MOVLW  01
0044:  MOVWF  01
0046:  CLRF   00
0048:  DECFSZ 00,F
004A:  BRA    0048
004C:  DECFSZ 01,F
004E:  BRA    0046
0050:  MOVLW  4A
0052:  MOVWF  00
0054:  DECFSZ 00,F
0056:  BRA    0054
0058:  BRA    005A
005A:  DECFSZ FEF,F
005C:  BRA    0042
005E:  RETLW  00
....................  
.................... #include "SHT11.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                           // 
.................... // Driver file for SHT75 Temperature & Humidity Sensor                       // 
.................... //                                                                           // 
.................... // ***** To initialise SHT75 sensor upon power up *****                      // 
.................... //                                                                           // 
.................... // Function : sht_init()                                                     // 
.................... // Return   : none                                                           // 
.................... //                                                                           // 
.................... //                                                                           // 
.................... // ***** To measure and caluculate SHT75 temp & real RH *****                // 
.................... //                                                                           // 
.................... // Function : sht_rd (temp, truehumid)                                       // 
.................... // Return   : temperature & true humidity in float values                    // 
.................... //                                                                           // 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................   
.................... #define sht_data_pin   PIN_B7 
.................... #define sht_clk_pin    PIN_B6 
....................  
.................... //***** Function to alert SHT75 ***** 
....................   
.................... void comstart (void) 
.................... { 
....................  output_float(sht_data_pin);  //data high 
*
012A:  BSF    F93.7
....................  output_low(sht_clk_pin);  //clk low 
012C:  BCF    F93.6
012E:  BCF    F8A.6
....................  delay_us(1); 
0130:  NOP   
....................  output_high(sht_clk_pin);  //clk high 
0132:  BCF    F93.6
0134:  BSF    F8A.6
....................  delay_us(1); 
0136:  NOP   
....................  output_low(sht_data_pin); //data low 
0138:  BCF    F93.7
013A:  BCF    F8A.7
....................  delay_us(1); 
013C:  NOP   
....................  output_low(sht_clk_pin);  //clk low 
013E:  BCF    F93.6
0140:  BCF    F8A.6
....................  delay_us(2); 
0142:  BRA    0144
....................  output_high(sht_clk_pin);  //clk high 
0144:  BCF    F93.6
0146:  BSF    F8A.6
....................  delay_us(1); 
0148:  NOP   
....................  output_float(sht_data_pin);  //data high 
014A:  BSF    F93.7
....................  delay_us(1); 
014C:  NOP   
....................  output_low(sht_clk_pin);  //clk low 
014E:  BCF    F93.6
0150:  BCF    F8A.6
.................... } 
0152:  RETLW  00
....................   
.................... //***** Function to write data to SHT75 ***** 
....................   
.................... int1 comwrite (int8 iobyte) 
.................... { 
*
0186:  MOVLW  80
0188:  MOVWF  29
....................  int8 i, mask = 0x80; 
....................  int1 ack; 
....................   
....................  //Shift out command 
....................  delay_us(4); 
018A:  BRA    018C
018C:  BRA    018E
....................  for(i=0; i<8; i++) 
018E:  CLRF   28
0190:  MOVF   28,W
0192:  SUBLW  07
0194:  BNC   01B8
....................   { 
....................    output_low(sht_clk_pin);                          //clk low 
0196:  BCF    F93.6
0198:  BCF    F8A.6
....................    if((iobyte & mask) > 0) output_float(sht_data_pin);  //data high if MSB high 
019A:  MOVF   27,W
019C:  ANDWF  29,W
019E:  BZ    01A4
01A0:  BSF    F93.7
....................    else output_low(sht_data_pin);                    //data low if MSB low 
01A2:  BRA    01A8
01A4:  BCF    F93.7
01A6:  BCF    F8A.7
....................    delay_us(1); 
01A8:  NOP   
....................    output_high(sht_clk_pin);                          //clk high 
01AA:  BCF    F93.6
01AC:  BSF    F8A.6
....................    delay_us(1); 
01AE:  NOP   
....................    mask = mask >> 1;                                    //shift to next bit 
01B0:  BCF    FD8.0
01B2:  RRCF   29,F
....................   } 
01B4:  INCF   28,F
01B6:  BRA    0190
....................   
....................  //Shift in ack 
....................  output_low(sht_clk_pin);  //clk low 
01B8:  BCF    F93.6
01BA:  BCF    F8A.6
....................  delay_us(1); 
01BC:  NOP   
....................  ack = input(sht_data_pin);   //get ack bit 
01BE:  BSF    F93.7
01C0:  BCF    2A.0
01C2:  BTFSC  F81.7
01C4:  BSF    2A.0
....................  output_high(sht_clk_pin);  //clk high 
01C6:  BCF    F93.6
01C8:  BSF    F8A.6
....................  delay_us(1); 
01CA:  NOP   
....................  output_low(sht_clk_pin);  //clk low 
01CC:  BCF    F93.6
01CE:  BCF    F8A.6
....................  return(ack); 
01D0:  MOVLW  00
01D2:  BTFSC  2A.0
01D4:  MOVLW  01
01D6:  MOVWF  01
.................... } 
01D8:  RETLW  00
....................   
.................... //***** Function to read data from SHT75 ***** 
....................   
.................... int16 comread (void) 
.................... { 
*
020E:  CLRF   29
0210:  CLRF   28
....................  int8 i; 
....................  int16 iobyte = 0; 
....................  const int16 mask0 = 0x0000; 
....................  const int16 mask1 = 0x0001; 
....................   
....................  //shift in MSB data 
....................  for(i=0; i<8; i++) 
0212:  CLRF   27
0214:  MOVF   27,W
0216:  SUBLW  07
0218:  BNC   023A
....................   { 
....................    iobyte = iobyte << 1; 
021A:  BCF    FD8.0
021C:  RLCF   28,F
021E:  RLCF   29,F
....................    output_high(sht_clk_pin);                //clk high 
0220:  BCF    F93.6
0222:  BSF    F8A.6
....................    delay_us(1); 
0224:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit 
0226:  BSF    F93.7
0228:  BTFSS  F81.7
022A:  BRA    0230
022C:  BSF    28.0
....................    else iobyte |= mask0; 
022E:  BRA    0230
....................    output_low(sht_clk_pin);                //clk low 
0230:  BCF    F93.6
0232:  BCF    F8A.6
....................    delay_us(1); 
0234:  NOP   
....................   } 
0236:  INCF   27,F
0238:  BRA    0214
....................   
....................  //send ack 0 bit 
....................  output_low(sht_data_pin); //data low 
023A:  BCF    F93.7
023C:  BCF    F8A.7
....................  delay_us(1); 
023E:  NOP   
....................  output_high(sht_clk_pin);  //clk high 
0240:  BCF    F93.6
0242:  BSF    F8A.6
....................  delay_us(2); 
0244:  BRA    0246
....................  output_low(sht_clk_pin);  //clk low 
0246:  BCF    F93.6
0248:  BCF    F8A.6
....................  delay_us(1); 
024A:  NOP   
....................  output_float(sht_data_pin);  //data high 
024C:  BSF    F93.7
....................   
....................  //shift in LSB data 
....................  for(i=0; i<8; i++) 
024E:  CLRF   27
0250:  MOVF   27,W
0252:  SUBLW  07
0254:  BNC   0276
....................   { 
....................    iobyte = iobyte << 1; 
0256:  BCF    FD8.0
0258:  RLCF   28,F
025A:  RLCF   29,F
....................    output_high(sht_clk_pin);                //clk high 
025C:  BCF    F93.6
025E:  BSF    F8A.6
....................    delay_us(1); 
0260:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit 
0262:  BSF    F93.7
0264:  BTFSS  F81.7
0266:  BRA    026C
0268:  BSF    28.0
....................    else iobyte |= mask0; 
026A:  BRA    026C
....................    output_low(sht_clk_pin);                //clk low 
026C:  BCF    F93.6
026E:  BCF    F8A.6
....................    delay_us(1); 
0270:  NOP   
....................   } 
0272:  INCF   27,F
0274:  BRA    0250
....................   
....................  //send ack 1 bit 
....................  output_float(sht_data_pin);  //data high 
0276:  BSF    F93.7
....................  delay_us(1); 
0278:  NOP   
....................  output_high(sht_clk_pin);  //clk high 
027A:  BCF    F93.6
027C:  BSF    F8A.6
....................  delay_us(2); 
027E:  BRA    0280
....................  output_low(sht_clk_pin);  //clk low 
0280:  BCF    F93.6
0282:  BCF    F8A.6
....................   
....................  return(iobyte); 
0284:  MOVFF  28,01
0288:  MOVFF  29,02
.................... } 
028C:  RETLW  00
....................   
.................... //***** Function to wait for SHT75 reading ***** 
....................   
.................... void comwait (void) 
.................... { 
....................  int16 sht_delay; 
....................   
....................  output_float(sht_data_pin);                     //data high 
*
01DA:  BSF    F93.7
....................  output_low(sht_clk_pin);                     //clk low 
01DC:  BCF    F93.6
01DE:  BCF    F8A.6
....................  delay_us(1); 
01E0:  NOP   
....................  for(sht_delay=0; sht_delay<30000; sht_delay++)  // wait for max 300ms 
01E2:  CLRF   28
01E4:  CLRF   27
01E6:  MOVF   28,W
01E8:  SUBLW  75
01EA:  BNC   020C
01EC:  BNZ   01F4
01EE:  MOVF   27,W
01F0:  SUBLW  2F
01F2:  BNC   020C
....................   { 
....................    if (!input(sht_data_pin)) break;              //if sht_data_pin low, SHT75 ready 
01F4:  BSF    F93.7
01F6:  BTFSC  F81.7
01F8:  BRA    01FC
01FA:  BRA    020C
....................    delay_us(10); 
01FC:  MOVLW  03
01FE:  MOVWF  00
0200:  DECFSZ 00,F
0202:  BRA    0200
....................   } 
0204:  INCF   27,F
0206:  BTFSC  FD8.2
0208:  INCF   28,F
020A:  BRA    01E6
.................... } 
020C:  RETLW  00
....................   
.................... //***** Function to reset SHT75 communication ***** 
....................   
.................... void comreset (void) 
.................... { 
....................  int8 i; 
....................   
....................  output_float(sht_data_pin);    //data high 
*
0154:  BSF    F93.7
....................  output_low(sht_clk_pin);    //clk low 
0156:  BCF    F93.6
0158:  BCF    F8A.6
....................  delay_us(2); 
015A:  BRA    015C
....................  for(i=0; i<9; i++) 
015C:  CLRF   14
015E:  MOVF   14,W
0160:  SUBLW  08
0162:  BNC   0174
....................   { 
....................    output_high(sht_clk_pin);  //toggle clk 9 times 
0164:  BCF    F93.6
0166:  BSF    F8A.6
....................    delay_us(2); 
0168:  BRA    016A
....................    output_low(sht_clk_pin); 
016A:  BCF    F93.6
016C:  BCF    F8A.6
....................    delay_us(2); 
016E:  BRA    0170
....................  } 
0170:  INCF   14,F
0172:  BRA    015E
....................  comstart(); 
0174:  RCALL  012A
.................... } 
0176:  GOTO   017C (RETURN)
....................   
.................... //***** Function to soft reset SHT75 ***** 
....................   
.................... void sht_soft_reset (void) 
.................... { 
....................  comreset();           //SHT75 communication reset 
....................  comwrite(0x1e);       //send SHT75 reset command 
....................  delay_ms(15);         //pause 15 ms 
.................... } 
....................   
.................... //***** Function to measure SHT75 temperature ***** 
....................   
.................... int16 measuretemp (void) 
.................... { 
....................  int1 ack; 
....................  int16 iobyte; 
....................   
....................  comstart();             //alert SHT75 
*
028E:  RCALL  012A
....................  ack = comwrite(0x03);   //send measure temp command and read ack status 
0290:  MOVLW  03
0292:  MOVWF  27
0294:  RCALL  0186
0296:  BCF    24.0
0298:  BTFSC  01.0
029A:  BSF    24.0
....................  if(ack == 1) return; 
029C:  BTFSS  24.0
029E:  BRA    02A2
02A0:  BRA    02B6
....................  comwait();              //wait for SHT75 measurement to complete 
02A2:  RCALL  01DA
....................  iobyte = comread();     //read SHT75 temp data 
02A4:  RCALL  020E
02A6:  MOVFF  02,26
02AA:  MOVFF  01,25
....................  return(iobyte); 
02AE:  MOVFF  25,01
02B2:  MOVFF  26,02
.................... } 
02B6:  GOTO   09A2 (RETURN)
....................   
.................... //***** Function to measure SHT75 RH ***** 
....................   
.................... int16 measurehumid (void) 
.................... { 
....................  int1 ack; 
....................  int16 iobyte; 
....................   
....................  comstart();            //alert SHT75 
02BA:  RCALL  012A
....................  ack = comwrite(0x05);  //send measure RH command and read ack status 
02BC:  MOVLW  05
02BE:  MOVWF  27
02C0:  RCALL  0186
02C2:  BCF    24.0
02C4:  BTFSC  01.0
02C6:  BSF    24.0
....................  if(ack == 1) return; 
02C8:  BTFSS  24.0
02CA:  BRA    02CE
02CC:  BRA    02E2
....................  comwait();             //wait for SHT75 measurement to complete 
02CE:  RCALL  01DA
....................  iobyte = comread();    //read SHT75 temp data 
02D0:  RCALL  020E
02D2:  MOVFF  02,26
02D6:  MOVFF  01,25
....................  return(iobyte); 
02DA:  MOVFF  25,01
02DE:  MOVFF  26,02
.................... } 
02E2:  GOTO   09AC (RETURN)
....................   
.................... //***** Function to calculate SHT75 temp & RH ***** 
....................   
.................... void calculate_data (int16 temp, int16 humid, float & tc, float & rhlin, float & rhtrue) 
.................... { 
....................  float truehumid1, rh; 
....................   
....................  //calculate temperature reading 
....................  tc = ((float) temp * 0.01) - 40.0; 
*
09C4:  MOVFF  25,3D
09C8:  MOVFF  24,3C
09CC:  RCALL  02E6
09CE:  MOVFF  00,30
09D2:  MOVFF  01,31
09D6:  MOVFF  02,32
09DA:  MOVFF  03,33
09DE:  MOVFF  03,47
09E2:  MOVFF  02,46
09E6:  MOVFF  01,45
09EA:  MOVFF  00,44
09EE:  MOVLW  0A
09F0:  MOVWF  4B
09F2:  MOVLW  D7
09F4:  MOVWF  4A
09F6:  MOVLW  23
09F8:  MOVWF  49
09FA:  MOVLW  78
09FC:  MOVWF  48
09FE:  RCALL  031C
0A00:  MOVFF  00,30
0A04:  MOVFF  01,31
0A08:  MOVFF  02,32
0A0C:  MOVFF  03,33
0A10:  BSF    FD8.1
0A12:  MOVFF  03,43
0A16:  MOVFF  02,42
0A1A:  MOVFF  01,41
0A1E:  MOVFF  00,40
0A22:  CLRF   47
0A24:  CLRF   46
0A26:  MOVLW  20
0A28:  MOVWF  45
0A2A:  MOVLW  84
0A2C:  MOVWF  44
0A2E:  RCALL  040E
0A30:  MOVFF  03,07
0A34:  MOVFF  02,06
0A38:  MOVFF  01,05
0A3C:  MOVFF  00,04
....................   
....................   
....................  //calculate Real RH reading 
....................  rh = (float) humid; 
0A40:  MOVFF  27,3D
0A44:  MOVFF  26,3C
0A48:  RCALL  02E6
0A4A:  MOVFF  03,2F
0A4E:  MOVFF  02,2E
0A52:  MOVFF  01,2D
0A56:  MOVFF  00,2C
....................   
....................  rhlin = (rh * 0.0405) - (rh * rh * 0.0000028) - 4.0; 
0A5A:  MOVFF  2F,47
0A5E:  MOVFF  2E,46
0A62:  MOVFF  2D,45
0A66:  MOVFF  2C,44
0A6A:  MOVLW  54
0A6C:  MOVWF  4B
0A6E:  MOVLW  E3
0A70:  MOVWF  4A
0A72:  MOVLW  25
0A74:  MOVWF  49
0A76:  MOVLW  7A
0A78:  MOVWF  48
0A7A:  RCALL  031C
0A7C:  MOVFF  00,30
0A80:  MOVFF  01,31
0A84:  MOVFF  02,32
0A88:  MOVFF  03,33
0A8C:  MOVFF  2F,47
0A90:  MOVFF  2E,46
0A94:  MOVFF  2D,45
0A98:  MOVFF  2C,44
0A9C:  MOVFF  2F,4B
0AA0:  MOVFF  2E,4A
0AA4:  MOVFF  2D,49
0AA8:  MOVFF  2C,48
0AAC:  RCALL  031C
0AAE:  MOVFF  00,34
0AB2:  MOVFF  01,35
0AB6:  MOVFF  02,36
0ABA:  MOVFF  03,37
0ABE:  MOVFF  03,47
0AC2:  MOVFF  02,46
0AC6:  MOVFF  01,45
0ACA:  MOVFF  00,44
0ACE:  MOVLW  A2
0AD0:  MOVWF  4B
0AD2:  MOVLW  E7
0AD4:  MOVWF  4A
0AD6:  MOVLW  3B
0AD8:  MOVWF  49
0ADA:  MOVLW  6C
0ADC:  MOVWF  48
0ADE:  RCALL  031C
0AE0:  BSF    FD8.1
0AE2:  MOVFF  33,43
0AE6:  MOVFF  32,42
0AEA:  MOVFF  31,41
0AEE:  MOVFF  30,40
0AF2:  MOVFF  03,47
0AF6:  MOVFF  02,46
0AFA:  MOVFF  01,45
0AFE:  MOVFF  00,44
0B02:  RCALL  040E
0B04:  MOVFF  00,30
0B08:  MOVFF  01,31
0B0C:  MOVFF  02,32
0B10:  MOVFF  03,33
0B14:  BSF    FD8.1
0B16:  MOVFF  03,43
0B1A:  MOVFF  02,42
0B1E:  MOVFF  01,41
0B22:  MOVFF  00,40
0B26:  CLRF   47
0B28:  CLRF   46
0B2A:  CLRF   45
0B2C:  MOVLW  81
0B2E:  MOVWF  44
0B30:  RCALL  040E
0B32:  MOVFF  03,1B
0B36:  MOVFF  02,1A
0B3A:  MOVFF  01,19
0B3E:  MOVFF  00,18
....................   
....................  //calculate True RH reading 
....................  rhtrue = ((tc - 25.0) * (0.01 + (0.00008 * rh))) + rhlin; 
0B42:  BSF    FD8.1
0B44:  MOVFF  07,43
0B48:  MOVFF  06,42
0B4C:  MOVFF  05,41
0B50:  MOVFF  04,40
0B54:  CLRF   47
0B56:  CLRF   46
0B58:  MOVLW  48
0B5A:  MOVWF  45
0B5C:  MOVLW  83
0B5E:  MOVWF  44
0B60:  RCALL  040E
0B62:  MOVFF  00,30
0B66:  MOVFF  01,31
0B6A:  MOVFF  02,32
0B6E:  MOVFF  03,33
0B72:  MOVLW  AC
0B74:  MOVWF  47
0B76:  MOVLW  C5
0B78:  MOVWF  46
0B7A:  MOVLW  27
0B7C:  MOVWF  45
0B7E:  MOVLW  71
0B80:  MOVWF  44
0B82:  MOVFF  2F,4B
0B86:  MOVFF  2E,4A
0B8A:  MOVFF  2D,49
0B8E:  MOVFF  2C,48
0B92:  CALL   031C
0B96:  BCF    FD8.1
0B98:  MOVLW  0A
0B9A:  MOVWF  43
0B9C:  MOVLW  D7
0B9E:  MOVWF  42
0BA0:  MOVLW  23
0BA2:  MOVWF  41
0BA4:  MOVLW  78
0BA6:  MOVWF  40
0BA8:  MOVFF  03,47
0BAC:  MOVFF  02,46
0BB0:  MOVFF  01,45
0BB4:  MOVFF  00,44
0BB8:  RCALL  040E
0BBA:  MOVFF  33,47
0BBE:  MOVFF  32,46
0BC2:  MOVFF  31,45
0BC6:  MOVFF  30,44
0BCA:  MOVFF  03,4B
0BCE:  MOVFF  02,4A
0BD2:  MOVFF  01,49
0BD6:  MOVFF  00,48
0BDA:  CALL   031C
0BDE:  MOVFF  00,30
0BE2:  MOVFF  01,31
0BE6:  MOVFF  02,32
0BEA:  MOVFF  03,33
0BEE:  BCF    FD8.1
0BF0:  MOVFF  03,43
0BF4:  MOVFF  02,42
0BF8:  MOVFF  01,41
0BFC:  MOVFF  00,40
0C00:  MOVFF  1B,47
0C04:  MOVFF  1A,46
0C08:  MOVFF  19,45
0C0C:  MOVFF  18,44
0C10:  CALL   040E
0C14:  MOVFF  03,0B
0C18:  MOVFF  02,0A
0C1C:  MOVFF  01,09
0C20:  MOVFF  00,08
.................... } 
....................   
.................... //***** Function to measure & calculate SHT75 temp & RH ***** 
....................   
.................... void sht_rd (float & temp, float & truehumid) 
.................... { 
....................  int16 restemp, reshumid; 
....................  float realhumid; 
....................  restemp = 0; truehumid = 0; 
*
0994:  CLRF   15
0996:  CLRF   14
0998:  CLRF   0B
099A:  CLRF   0A
099C:  CLRF   09
099E:  CLRF   08
....................   
....................  restemp = measuretemp();    //measure temp 
09A0:  BRA    028E
09A2:  MOVFF  02,15
09A6:  MOVFF  01,14
....................  reshumid = measurehumid();  //measure RH 
09AA:  BRA    02BA
09AC:  MOVFF  02,17
09B0:  MOVFF  01,16
.................... calculate_data (restemp, reshumid, temp, realhumid, truehumid);  //calculate temp & RH 
09B4:  MOVFF  15,25
09B8:  MOVFF  14,24
09BC:  MOVFF  17,27
09C0:  MOVFF  16,26
.................... } 
....................   
.................... //***** Function to initialise SHT75 on power-up ***** 
....................   
.................... void sht_init (void) 
.................... { 
....................  comreset();    //reset SHT75 
*
017A:  BRA    0154
....................  delay_ms(20);  //delay for power-up 
017C:  MOVLW  14
017E:  MOVWF  22
0180:  RCALL  0038
.................... } 
0182:  GOTO   098C (RETURN)
....................  
....................  
....................  
.................... #include "new_lcd.c" 
.................... // flex_lcd.c 
....................  
.................... // These pins are for the Microchip PicDem2-Plus board, 
.................... // which is what I used to test the driver.  Change these 
.................... // pins to fit your own board. 
....................  
.................... #define LCD_DB4   PIN_D4 
.................... #define LCD_DB5   PIN_D5 
.................... #define LCD_DB6   PIN_D6 
.................... #define LCD_DB7   PIN_D7 
....................  
.................... #define LCD_E     PIN_D0 
.................... #define LCD_RS    PIN_D1 
.................... //#define LCD_RW    0 
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... //#define USE_LCD_RW   1 
....................  
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... //======================================== 
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0x0C,//0xf,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
....................  
.................... /* 
.................... byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xC, 1,6}; 
....................  
.................... Value   Cursor  Blink 
.................... 0x0C     Off      Off 
.................... 0x0D     Off      On 
.................... 0x0E     On       Off 
.................... 0x0F     On       On 
....................  
.................... */ 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
*
0060:  BTFSC  29.0
0062:  BRA    0068
0064:  BCF    F8C.4
0066:  BRA    006A
0068:  BSF    F8C.4
006A:  BCF    F95.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
006C:  BTFSC  29.1
006E:  BRA    0074
0070:  BCF    F8C.5
0072:  BRA    0076
0074:  BSF    F8C.5
0076:  BCF    F95.5
....................  output_bit(LCD_DB6, !!(nibble & 4)); 
0078:  BTFSC  29.2
007A:  BRA    0080
007C:  BCF    F8C.6
007E:  BRA    0082
0080:  BSF    F8C.6
0082:  BCF    F95.6
....................  output_bit(LCD_DB7, !!(nibble & 8)); 
0084:  BTFSC  29.3
0086:  BRA    008C
0088:  BCF    F8C.7
008A:  BRA    008E
008C:  BSF    F8C.7
008E:  BCF    F95.7
....................  
....................  delay_cycles(1); 
0090:  NOP   
....................  output_high(LCD_E); 
0092:  BCF    F95.0
0094:  BSF    F8C.0
....................  delay_us(2); 
0096:  BRA    0098
....................  output_low(LCD_E); 
0098:  BCF    F95.0
009A:  BCF    F8C.0
.................... } 
009C:  RETLW  00
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
....................  
.................... output_high(LCD_E); 
.................... delay_cycles(1); 
....................  
.................... retval_0 = input(LCD_DB4); 
.................... retval_1 = input(LCD_DB5); 
.................... retval_2 = input(LCD_DB6); 
.................... retval_3 = input(LCD_DB7); 
....................  
.................... output_low(LCD_E); 
....................  
.................... return(retval); 
.................... } 
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
.................... delay_cycles(1); 
....................  
.................... high = lcd_read_nibble(); 
....................  
.................... low = lcd_read_nibble(); 
....................  
.................... return( (high<<4) | low); 
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
009E:  BCF    F95.1
00A0:  BCF    F8C.1
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
.................... #else 
.................... delay_us(60); 
00A2:  MOVLW  13
00A4:  MOVWF  00
00A6:  DECFSZ 00,F
00A8:  BRA    00A6
00AA:  BRA    00AC
.................... #endif 
....................  
.................... if(address) 
00AC:  MOVF   26,F
00AE:  BZ    00B6
....................    output_high(LCD_RS); 
00B0:  BCF    F95.1
00B2:  BSF    F8C.1
.................... else 
00B4:  BRA    00BA
....................    output_low(LCD_RS); 
00B6:  BCF    F95.1
00B8:  BCF    F8C.1
....................  
....................  delay_cycles(1); 
00BA:  NOP   
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... delay_cycles(1); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
00BC:  BCF    F95.0
00BE:  BCF    F8C.0
....................  
.................... lcd_send_nibble(n >> 4); 
00C0:  SWAPF  27,W
00C2:  MOVWF  28
00C4:  MOVLW  0F
00C6:  ANDWF  28,F
00C8:  MOVFF  28,29
00CC:  RCALL  0060
.................... lcd_send_nibble(n & 0xf); 
00CE:  MOVF   27,W
00D0:  ANDLW  0F
00D2:  MOVWF  28
00D4:  MOVWF  29
00D6:  RCALL  0060
.................... } 
00D8:  RETLW  00
....................  
.................... //---------------------------- 
....................  
....................  
.................... void lcd_setcursor_vb(short visible, short blink) { 
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink); 
.................... } 
....................  
....................  
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... output_low(LCD_RS); 
00DA:  BCF    F95.1
00DC:  BCF    F8C.1
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
00DE:  BCF    F95.0
00E0:  BCF    F8C.0
....................  
.................... delay_ms(15); 
00E2:  MOVLW  0F
00E4:  MOVWF  22
00E6:  RCALL  0038
....................  
.................... for(i=0 ;i < 3; i++) 
00E8:  CLRF   14
00EA:  MOVF   14,W
00EC:  SUBLW  02
00EE:  BNC   0100
....................    { 
....................     lcd_send_nibble(0x03); 
00F0:  MOVLW  03
00F2:  MOVWF  29
00F4:  RCALL  0060
....................     delay_ms(5); 
00F6:  MOVLW  05
00F8:  MOVWF  22
00FA:  RCALL  0038
....................    } 
00FC:  INCF   14,F
00FE:  BRA    00EA
....................  
.................... lcd_send_nibble(0x02); 
0100:  MOVLW  02
0102:  MOVWF  29
0104:  RCALL  0060
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
0106:  CLRF   14
0108:  MOVF   14,W
010A:  SUBLW  03
010C:  BNC   0126
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
010E:  CLRF   03
0110:  MOVF   14,W
0112:  RCALL  0004
0114:  MOVWF  15
0116:  CLRF   26
0118:  MOVWF  27
011A:  RCALL  009E
....................  
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled.  One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 60 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
....................     #ifndef USE_LCD_RW 
....................     delay_ms(5); 
011C:  MOVLW  05
011E:  MOVWF  22
0120:  RCALL  0038
....................     #endif 
....................    } 
0122:  INCF   14,F
0124:  BRA    0108
....................  
.................... } 
0126:  GOTO   0980 (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
.................... if(y != 1) 
*
0678:  DECFSZ 23,W
067A:  BRA    067E
067C:  BRA    0684
....................    address = lcd_line_two; 
067E:  MOVLW  40
0680:  MOVWF  24
.................... else 
0682:  BRA    0686
....................    address=0; 
0684:  CLRF   24
....................  
.................... address += x-1; 
0686:  MOVLW  01
0688:  SUBWF  22,W
068A:  ADDWF  24,F
.................... lcd_send_byte(0, 0x80 | address); 
068C:  MOVF   24,W
068E:  IORLW  80
0690:  MOVWF  25
0692:  CLRF   26
0694:  MOVWF  27
0696:  RCALL  009E
.................... } 
0698:  RETLW  00
....................  
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
069A:  MOVF   21,W
069C:  XORLW  0C
069E:  BZ    06AA
06A0:  XORLW  06
06A2:  BZ    06BA
06A4:  XORLW  02
06A6:  BZ    06C6
06A8:  BRA    06D0
....................     case '\f': 
....................       lcd_send_byte(0,1); 
06AA:  CLRF   26
06AC:  MOVLW  01
06AE:  MOVWF  27
06B0:  RCALL  009E
....................       delay_ms(2); 
06B2:  MOVLW  02
06B4:  MOVWF  22
06B6:  RCALL  0038
....................       break; 
06B8:  BRA    06DC
....................  
....................     case '\n': 
....................        lcd_gotoxy(1,2); 
06BA:  MOVLW  01
06BC:  MOVWF  22
06BE:  MOVLW  02
06C0:  MOVWF  23
06C2:  RCALL  0678
....................        break; 
06C4:  BRA    06DC
....................  
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
06C6:  CLRF   26
06C8:  MOVLW  10
06CA:  MOVWF  27
06CC:  RCALL  009E
....................        break; 
06CE:  BRA    06DC
....................  
....................     default: 
....................        lcd_send_byte(1,c); 
06D0:  MOVLW  01
06D2:  MOVWF  26
06D4:  MOVFF  21,27
06D8:  RCALL  009E
....................        break; 
06DA:  BRA    06DC
....................    } 
.................... } 
06DC:  RETLW  00
....................  
.................... //------------------------------ 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7)); 
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(lcd_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define sht_data_pin   PIN_b7//(Data pin veya input) 
.................... #define sht_clk_pin    PIN_b6 
....................  
.................... float temp,humid,sicaklik,nem; 
....................  
....................  
....................  
.................... void main() 
.................... { 
*
0934:  CLRF   FF8
0936:  BCF    FD0.7
0938:  CLRF   FEA
093A:  CLRF   FE9
093C:  BSF    FC1.0
093E:  BSF    FC1.1
0940:  BSF    FC1.2
0942:  BCF    FC1.3
....................  
....................    setup_adc_ports(NO_ANALOGS); 
0944:  BSF    FC1.0
0946:  BSF    FC1.1
0948:  BSF    FC1.2
094A:  BCF    FC1.3
....................    setup_adc(ADC_CLOCK_DIV_2); 
094C:  BCF    FC1.6
094E:  BCF    FC2.6
0950:  BCF    FC2.7
0952:  BCF    FC1.7
0954:  BSF    FC2.0
....................    setup_psp(PSP_DISABLED); 
0956:  BCF    F96.4
....................    setup_spi(SPI_SS_DISABLED); 
0958:  BCF    FC6.5
095A:  BCF    F94.5
095C:  BSF    F94.4
095E:  BCF    F94.3
0960:  MOVLW  01
0962:  MOVWF  FC6
0964:  MOVLW  00
0966:  MOVWF  FC7
....................    setup_wdt(WDT_OFF); 
0968:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
096A:  MOVLW  80
096C:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
096E:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
0970:  MOVLW  00
0972:  MOVWF  FCA
0974:  MOVLW  00
0976:  MOVWF  FCB
....................    setup_ccp1(CCP_OFF); 
0978:  BSF    F94.2
097A:  CLRF   FBD
....................     
....................  
....................    lcd_init(); 
097C:  GOTO   00DA
....................    delay_ms(100); 
0980:  MOVLW  64
0982:  MOVWF  22
0984:  CALL   0038
....................    sht_init(); 
0988:  GOTO   017A
....................    delay_ms(100); 
098C:  MOVLW  64
098E:  MOVWF  22
0990:  CALL   0038
....................     
....................    while(1){ 
....................       sht_rd (temp, humid); 
....................       sicaklik=(float)temp; 
*
0C24:  MOVFF  07,0F
0C28:  MOVFF  06,0E
0C2C:  MOVFF  05,0D
0C30:  MOVFF  04,0C
....................       nem=(float)humid; 
0C34:  MOVFF  0B,13
0C38:  MOVFF  0A,12
0C3C:  MOVFF  09,11
0C40:  MOVFF  08,10
....................       lcd_gotoxy(1,1); 
0C44:  MOVLW  01
0C46:  MOVWF  22
0C48:  MOVWF  23
0C4A:  RCALL  0678
....................       printf(lcd_putc,"SICAKLIK %2.2f C",sicaklik); 
0C4C:  MOVLW  18
0C4E:  MOVWF  FF6
0C50:  MOVLW  00
0C52:  MOVWF  FF7
0C54:  MOVLW  09
0C56:  MOVWF  14
0C58:  RCALL  06DE
0C5A:  MOVLW  89
0C5C:  MOVWF  FE9
0C5E:  MOVFF  0F,17
0C62:  MOVFF  0E,16
0C66:  MOVFF  0D,15
0C6A:  MOVFF  0C,14
0C6E:  MOVLW  02
0C70:  MOVWF  18
0C72:  RCALL  07B6
0C74:  MOVLW  20
0C76:  MOVWF  21
0C78:  RCALL  069A
0C7A:  MOVLW  43
0C7C:  MOVWF  21
0C7E:  RCALL  069A
....................       lcd_gotoxy(1,2); 
0C80:  MOVLW  01
0C82:  MOVWF  22
0C84:  MOVLW  02
0C86:  MOVWF  23
0C88:  RCALL  0678
....................       printf(lcd_putc,"NEM %2.2f RH",nem); 
0C8A:  MOVLW  2A
0C8C:  MOVWF  FF6
0C8E:  MOVLW  00
0C90:  MOVWF  FF7
0C92:  MOVLW  04
0C94:  MOVWF  14
0C96:  RCALL  06DE
0C98:  MOVLW  89
0C9A:  MOVWF  FE9
0C9C:  MOVFF  13,17
0CA0:  MOVFF  12,16
0CA4:  MOVFF  11,15
0CA8:  MOVFF  10,14
0CAC:  MOVLW  02
0CAE:  MOVWF  18
0CB0:  RCALL  07B6
0CB2:  MOVLW  20
0CB4:  MOVWF  21
0CB6:  RCALL  069A
0CB8:  MOVLW  52
0CBA:  MOVWF  21
0CBC:  RCALL  069A
0CBE:  MOVLW  48
0CC0:  MOVWF  21
0CC2:  RCALL  069A
....................       delay_ms(200); 
0CC4:  MOVLW  C8
0CC6:  MOVWF  22
0CC8:  CALL   0038
....................     
....................    } 
0CCC:  BRA    0994
....................  
.................... } 
....................  
....................  
0CCE:  SLEEP 

Configuration Fuses:
   Word  1: 2100   XT NOOSCSEN
   Word  2: 0E0D   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 0100   CCP2C1
   Word  4: 0080   NOSTVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
