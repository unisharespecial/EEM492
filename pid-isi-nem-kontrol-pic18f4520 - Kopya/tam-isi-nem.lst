CCS PCH C Compiler, Version 4.106, 18916               25-Nis-14 15:45

               Filename: C:\Users\Akýn\Desktop\pid-isi-nem-kontrol-pic18f4520\tam-isi-nem.lst

               ROM used: 5944 bytes (18%)
                         Largest free fragment is 26824
               RAM used: 70 (5%) at main() level
                         122 (8%) worst case
               Stack:    5 locations

*
0000:  GOTO   0DA8
.................... #include <18F452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES XT                       //Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOOSCSEN                 //Oscillator switching is disabled, main oscillator is source 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOSTVREN                 //Stack full/underflow will not cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(clock=4000000) 
*
0070:  CLRF   FEA
0072:  MOVLW  4C
0074:  MOVWF  FE9
0076:  MOVF   FEF,W
0078:  BZ    0096
007A:  MOVLW  01
007C:  MOVWF  01
007E:  CLRF   00
0080:  DECFSZ 00,F
0082:  BRA    0080
0084:  DECFSZ 01,F
0086:  BRA    007E
0088:  MOVLW  4A
008A:  MOVWF  00
008C:  DECFSZ 00,F
008E:  BRA    008C
0090:  BRA    0092
0092:  DECFSZ FEF,F
0094:  BRA    007A
0096:  RETLW  00
....................  
.................... #include "SHT11.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                           // 
.................... // Driver file for SHT75 Temperature & Humidity Sensor                       // 
.................... //                                                                           // 
.................... // ***** To initialise SHT75 sensor upon power up *****                      // 
.................... //                                                                           // 
.................... // Function : sht_init()                                                     // 
.................... // Return   : none                                                           // 
.................... //                                                                           // 
.................... //                                                                           // 
.................... // ***** To measure and caluculate SHT75 temp & real RH *****                // 
.................... //                                                                           // 
.................... // Function : sht_rd (temp, truehumid)                                       // 
.................... // Return   : temperature & true humidity in float values                    // 
.................... //                                                                           // 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................   
.................... #define sht_data_pin   PIN_B7 
.................... #define sht_clk_pin    PIN_B6 
....................  
.................... //***** Function to alert SHT75 ***** 
....................   
.................... void comstart (void) 
.................... { 
....................  output_float(sht_data_pin);  //data high 
*
0160:  BSF    F93.7
....................  output_low(sht_clk_pin);  //clk low 
0162:  BCF    F93.6
0164:  BCF    F8A.6
....................  delay_us(1); 
0166:  NOP   
....................  output_high(sht_clk_pin);  //clk high 
0168:  BCF    F93.6
016A:  BSF    F8A.6
....................  delay_us(1); 
016C:  NOP   
....................  output_low(sht_data_pin); //data low 
016E:  BCF    F93.7
0170:  BCF    F8A.7
....................  delay_us(1); 
0172:  NOP   
....................  output_low(sht_clk_pin);  //clk low 
0174:  BCF    F93.6
0176:  BCF    F8A.6
....................  delay_us(2); 
0178:  BRA    017A
....................  output_high(sht_clk_pin);  //clk high 
017A:  BCF    F93.6
017C:  BSF    F8A.6
....................  delay_us(1); 
017E:  NOP   
....................  output_float(sht_data_pin);  //data high 
0180:  BSF    F93.7
....................  delay_us(1); 
0182:  NOP   
....................  output_low(sht_clk_pin);  //clk low 
0184:  BCF    F93.6
0186:  BCF    F8A.6
.................... } 
0188:  RETLW  00
....................   
.................... //***** Function to write data to SHT75 ***** 
....................   
.................... int1 comwrite (int8 iobyte) 
.................... { 
*
04A4:  MOVLW  80
04A6:  MOVWF  53
....................  int8 i, mask = 0x80; 
....................  int1 ack; 
....................   
....................  //Shift out command 
....................  delay_us(4); 
04A8:  BRA    04AA
04AA:  BRA    04AC
....................  for(i=0; i<8; i++) 
04AC:  CLRF   52
04AE:  MOVF   52,W
04B0:  SUBLW  07
04B2:  BNC   04D6
....................   { 
....................    output_low(sht_clk_pin);                          //clk low 
04B4:  BCF    F93.6
04B6:  BCF    F8A.6
....................    if((iobyte & mask) > 0) output_float(sht_data_pin);  //data high if MSB high 
04B8:  MOVF   51,W
04BA:  ANDWF  53,W
04BC:  BZ    04C2
04BE:  BSF    F93.7
....................    else output_low(sht_data_pin);                    //data low if MSB low 
04C0:  BRA    04C6
04C2:  BCF    F93.7
04C4:  BCF    F8A.7
....................    delay_us(1); 
04C6:  NOP   
....................    output_high(sht_clk_pin);                          //clk high 
04C8:  BCF    F93.6
04CA:  BSF    F8A.6
....................    delay_us(1); 
04CC:  NOP   
....................    mask = mask >> 1;                                    //shift to next bit 
04CE:  BCF    FD8.0
04D0:  RRCF   53,F
....................   } 
04D2:  INCF   52,F
04D4:  BRA    04AE
....................   
....................  //Shift in ack 
....................  output_low(sht_clk_pin);  //clk low 
04D6:  BCF    F93.6
04D8:  BCF    F8A.6
....................  delay_us(1); 
04DA:  NOP   
....................  ack = input(sht_data_pin);   //get ack bit 
04DC:  BSF    F93.7
04DE:  BCF    54.0
04E0:  BTFSC  F81.7
04E2:  BSF    54.0
....................  output_high(sht_clk_pin);  //clk high 
04E4:  BCF    F93.6
04E6:  BSF    F8A.6
....................  delay_us(1); 
04E8:  NOP   
....................  output_low(sht_clk_pin);  //clk low 
04EA:  BCF    F93.6
04EC:  BCF    F8A.6
....................  return(ack); 
04EE:  MOVLW  00
04F0:  BTFSC  54.0
04F2:  MOVLW  01
04F4:  MOVWF  01
.................... } 
04F6:  RETLW  00
....................   
.................... //***** Function to read data from SHT75 ***** 
....................   
.................... int16 comread (void) 
.................... { 
*
052C:  CLRF   53
052E:  CLRF   52
....................  int8 i; 
....................  int16 iobyte = 0; 
....................  const int16 mask0 = 0x0000; 
....................  const int16 mask1 = 0x0001; 
....................   
....................  //shift in MSB data 
....................  for(i=0; i<8; i++) 
0530:  CLRF   51
0532:  MOVF   51,W
0534:  SUBLW  07
0536:  BNC   0558
....................   { 
....................    iobyte = iobyte << 1; 
0538:  BCF    FD8.0
053A:  RLCF   52,F
053C:  RLCF   53,F
....................    output_high(sht_clk_pin);                //clk high 
053E:  BCF    F93.6
0540:  BSF    F8A.6
....................    delay_us(1); 
0542:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit 
0544:  BSF    F93.7
0546:  BTFSS  F81.7
0548:  BRA    054E
054A:  BSF    52.0
....................    else iobyte |= mask0; 
054C:  BRA    054E
....................    output_low(sht_clk_pin);                //clk low 
054E:  BCF    F93.6
0550:  BCF    F8A.6
....................    delay_us(1); 
0552:  NOP   
....................   } 
0554:  INCF   51,F
0556:  BRA    0532
....................   
....................  //send ack 0 bit 
....................  output_low(sht_data_pin); //data low 
0558:  BCF    F93.7
055A:  BCF    F8A.7
....................  delay_us(1); 
055C:  NOP   
....................  output_high(sht_clk_pin);  //clk high 
055E:  BCF    F93.6
0560:  BSF    F8A.6
....................  delay_us(2); 
0562:  BRA    0564
....................  output_low(sht_clk_pin);  //clk low 
0564:  BCF    F93.6
0566:  BCF    F8A.6
....................  delay_us(1); 
0568:  NOP   
....................  output_float(sht_data_pin);  //data high 
056A:  BSF    F93.7
....................   
....................  //shift in LSB data 
....................  for(i=0; i<8; i++) 
056C:  CLRF   51
056E:  MOVF   51,W
0570:  SUBLW  07
0572:  BNC   0594
....................   { 
....................    iobyte = iobyte << 1; 
0574:  BCF    FD8.0
0576:  RLCF   52,F
0578:  RLCF   53,F
....................    output_high(sht_clk_pin);                //clk high 
057A:  BCF    F93.6
057C:  BSF    F8A.6
....................    delay_us(1); 
057E:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit 
0580:  BSF    F93.7
0582:  BTFSS  F81.7
0584:  BRA    058A
0586:  BSF    52.0
....................    else iobyte |= mask0; 
0588:  BRA    058A
....................    output_low(sht_clk_pin);                //clk low 
058A:  BCF    F93.6
058C:  BCF    F8A.6
....................    delay_us(1); 
058E:  NOP   
....................   } 
0590:  INCF   51,F
0592:  BRA    056E
....................   
....................  //send ack 1 bit 
....................  output_float(sht_data_pin);  //data high 
0594:  BSF    F93.7
....................  delay_us(1); 
0596:  NOP   
....................  output_high(sht_clk_pin);  //clk high 
0598:  BCF    F93.6
059A:  BSF    F8A.6
....................  delay_us(2); 
059C:  BRA    059E
....................  output_low(sht_clk_pin);  //clk low 
059E:  BCF    F93.6
05A0:  BCF    F8A.6
....................   
....................  return(iobyte); 
05A2:  MOVFF  52,01
05A6:  MOVFF  53,02
.................... } 
05AA:  RETLW  00
....................   
.................... //***** Function to wait for SHT75 reading ***** 
....................   
.................... void comwait (void) 
.................... { 
....................  int16 sht_delay; 
....................   
....................  output_float(sht_data_pin);                     //data high 
*
04F8:  BSF    F93.7
....................  output_low(sht_clk_pin);                     //clk low 
04FA:  BCF    F93.6
04FC:  BCF    F8A.6
....................  delay_us(1); 
04FE:  NOP   
....................  for(sht_delay=0; sht_delay<30000; sht_delay++)  // wait for max 300ms 
0500:  CLRF   52
0502:  CLRF   51
0504:  MOVF   52,W
0506:  SUBLW  75
0508:  BNC   052A
050A:  BNZ   0512
050C:  MOVF   51,W
050E:  SUBLW  2F
0510:  BNC   052A
....................   { 
....................    if (!input(sht_data_pin)) break;              //if sht_data_pin low, SHT75 ready 
0512:  BSF    F93.7
0514:  BTFSC  F81.7
0516:  BRA    051A
0518:  BRA    052A
....................    delay_us(10); 
051A:  MOVLW  03
051C:  MOVWF  00
051E:  DECFSZ 00,F
0520:  BRA    051E
....................   } 
0522:  INCF   51,F
0524:  BTFSC  FD8.2
0526:  INCF   52,F
0528:  BRA    0504
.................... } 
052A:  RETLW  00
....................   
.................... //***** Function to reset SHT75 communication ***** 
....................   
.................... void comreset (void) 
.................... { 
....................  int8 i; 
....................   
....................  output_float(sht_data_pin);    //data high 
*
018A:  BSF    F93.7
....................  output_low(sht_clk_pin);    //clk low 
018C:  BCF    F93.6
018E:  BCF    F8A.6
....................  delay_us(2); 
0190:  BRA    0192
....................  for(i=0; i<9; i++) 
0192:  CLRF   3E
0194:  MOVF   3E,W
0196:  SUBLW  08
0198:  BNC   01AA
....................   { 
....................    output_high(sht_clk_pin);  //toggle clk 9 times 
019A:  BCF    F93.6
019C:  BSF    F8A.6
....................    delay_us(2); 
019E:  BRA    01A0
....................    output_low(sht_clk_pin); 
01A0:  BCF    F93.6
01A2:  BCF    F8A.6
....................    delay_us(2); 
01A4:  BRA    01A6
....................  } 
01A6:  INCF   3E,F
01A8:  BRA    0194
....................  comstart(); 
01AA:  RCALL  0160
.................... } 
01AC:  GOTO   01B2 (RETURN)
....................   
.................... //***** Function to soft reset SHT75 ***** 
....................   
.................... void sht_soft_reset (void) 
.................... { 
....................  comreset();           //SHT75 communication reset 
....................  comwrite(0x1e);       //send SHT75 reset command 
....................  delay_ms(15);         //pause 15 ms 
.................... } 
....................   
.................... //***** Function to measure SHT75 temperature ***** 
....................   
.................... int16 measuretemp (void) 
.................... { 
....................  int1 ack; 
....................  int16 iobyte; 
....................   
....................  comstart();             //alert SHT75 
*
05AC:  RCALL  0160
....................  ack = comwrite(0x03);   //send measure temp command and read ack status 
05AE:  MOVLW  03
05B0:  MOVWF  51
05B2:  RCALL  04A4
05B4:  BCF    4E.0
05B6:  BTFSC  01.0
05B8:  BSF    4E.0
....................  if(ack == 1) return; 
05BA:  BTFSS  4E.0
05BC:  BRA    05C0
05BE:  BRA    05D4
....................  comwait();              //wait for SHT75 measurement to complete 
05C0:  RCALL  04F8
....................  iobyte = comread();     //read SHT75 temp data 
05C2:  RCALL  052C
05C4:  MOVFF  02,50
05C8:  MOVFF  01,4F
....................  return(iobyte); 
05CC:  MOVFF  4F,01
05D0:  MOVFF  50,02
.................... } 
05D4:  GOTO   0FCC (RETURN)
....................   
.................... //***** Function to measure SHT75 RH ***** 
....................   
.................... int16 measurehumid (void) 
.................... { 
....................  int1 ack; 
....................  int16 iobyte; 
....................   
....................  comstart();            //alert SHT75 
05D8:  RCALL  0160
....................  ack = comwrite(0x05);  //send measure RH command and read ack status 
05DA:  MOVLW  05
05DC:  MOVWF  51
05DE:  RCALL  04A4
05E0:  BCF    4E.0
05E2:  BTFSC  01.0
05E4:  BSF    4E.0
....................  if(ack == 1) return; 
05E6:  BTFSS  4E.0
05E8:  BRA    05EC
05EA:  BRA    0600
....................  comwait();             //wait for SHT75 measurement to complete 
05EC:  RCALL  04F8
....................  iobyte = comread();    //read SHT75 temp data 
05EE:  RCALL  052C
05F0:  MOVFF  02,50
05F4:  MOVFF  01,4F
....................  return(iobyte); 
05F8:  MOVFF  4F,01
05FC:  MOVFF  50,02
.................... } 
0600:  GOTO   0FD8 (RETURN)
....................   
.................... //***** Function to calculate SHT75 temp & RH ***** 
....................   
.................... void calculate_data (int16 temp, int16 humid, float & tc, float & rhlin, float & rhtrue) 
.................... { 
....................  float truehumid1, rh; 
....................   
....................  //calculate temperature reading 
....................  tc = ((float) temp * 0.01) - 40.0; 
*
0FF0:  MOVFF  4F,67
0FF4:  MOVFF  4E,66
0FF8:  CALL   0604
0FFC:  MOVFF  00,5A
1000:  MOVFF  01,5B
1004:  MOVFF  02,5C
1008:  MOVFF  03,5D
100C:  MOVFF  03,71
1010:  MOVFF  02,70
1014:  MOVFF  01,6F
1018:  MOVFF  00,6E
101C:  MOVLW  0A
101E:  MOVWF  75
1020:  MOVLW  D7
1022:  MOVWF  74
1024:  MOVLW  23
1026:  MOVWF  73
1028:  MOVLW  78
102A:  MOVWF  72
102C:  CALL   063A
1030:  MOVFF  00,5A
1034:  MOVFF  01,5B
1038:  MOVFF  02,5C
103C:  MOVFF  03,5D
1040:  BSF    FD8.1
1042:  MOVFF  03,6D
1046:  MOVFF  02,6C
104A:  MOVFF  01,6B
104E:  MOVFF  00,6A
1052:  CLRF   71
1054:  CLRF   70
1056:  MOVLW  20
1058:  MOVWF  6F
105A:  MOVLW  84
105C:  MOVWF  6E
105E:  CALL   072C
1062:  MOVFF  03,07
1066:  MOVFF  02,06
106A:  MOVFF  01,05
106E:  MOVFF  00,04
....................   
....................   
....................  //calculate Real RH reading 
....................  rh = (float) humid; 
1072:  MOVFF  51,67
1076:  MOVFF  50,66
107A:  CALL   0604
107E:  MOVFF  03,59
1082:  MOVFF  02,58
1086:  MOVFF  01,57
108A:  MOVFF  00,56
....................   
....................  rhlin = (rh * 0.0405) - (rh * rh * 0.0000028) - 4.0; 
108E:  MOVFF  59,71
1092:  MOVFF  58,70
1096:  MOVFF  57,6F
109A:  MOVFF  56,6E
109E:  MOVLW  54
10A0:  MOVWF  75
10A2:  MOVLW  E3
10A4:  MOVWF  74
10A6:  MOVLW  25
10A8:  MOVWF  73
10AA:  MOVLW  7A
10AC:  MOVWF  72
10AE:  CALL   063A
10B2:  MOVFF  00,5A
10B6:  MOVFF  01,5B
10BA:  MOVFF  02,5C
10BE:  MOVFF  03,5D
10C2:  MOVFF  59,71
10C6:  MOVFF  58,70
10CA:  MOVFF  57,6F
10CE:  MOVFF  56,6E
10D2:  MOVFF  59,75
10D6:  MOVFF  58,74
10DA:  MOVFF  57,73
10DE:  MOVFF  56,72
10E2:  CALL   063A
10E6:  MOVFF  00,5E
10EA:  MOVFF  01,5F
10EE:  MOVFF  02,60
10F2:  MOVFF  03,61
10F6:  MOVFF  03,71
10FA:  MOVFF  02,70
10FE:  MOVFF  01,6F
1102:  MOVFF  00,6E
1106:  MOVLW  A2
1108:  MOVWF  75
110A:  MOVLW  E7
110C:  MOVWF  74
110E:  MOVLW  3B
1110:  MOVWF  73
1112:  MOVLW  6C
1114:  MOVWF  72
1116:  CALL   063A
111A:  BSF    FD8.1
111C:  MOVFF  5D,6D
1120:  MOVFF  5C,6C
1124:  MOVFF  5B,6B
1128:  MOVFF  5A,6A
112C:  MOVFF  03,71
1130:  MOVFF  02,70
1134:  MOVFF  01,6F
1138:  MOVFF  00,6E
113C:  CALL   072C
1140:  MOVFF  00,5A
1144:  MOVFF  01,5B
1148:  MOVFF  02,5C
114C:  MOVFF  03,5D
1150:  BSF    FD8.1
1152:  MOVFF  03,6D
1156:  MOVFF  02,6C
115A:  MOVFF  01,6B
115E:  MOVFF  00,6A
1162:  CLRF   71
1164:  CLRF   70
1166:  CLRF   6F
1168:  MOVLW  81
116A:  MOVWF  6E
116C:  CALL   072C
1170:  MOVFF  03,45
1174:  MOVFF  02,44
1178:  MOVFF  01,43
117C:  MOVFF  00,42
....................   
....................  //calculate True RH reading 
....................  rhtrue = ((tc - 25.0) * (0.01 + (0.00008 * rh))) + rhlin; 
1180:  BSF    FD8.1
1182:  MOVFF  07,6D
1186:  MOVFF  06,6C
118A:  MOVFF  05,6B
118E:  MOVFF  04,6A
1192:  CLRF   71
1194:  CLRF   70
1196:  MOVLW  48
1198:  MOVWF  6F
119A:  MOVLW  83
119C:  MOVWF  6E
119E:  CALL   072C
11A2:  MOVFF  00,5A
11A6:  MOVFF  01,5B
11AA:  MOVFF  02,5C
11AE:  MOVFF  03,5D
11B2:  MOVLW  AC
11B4:  MOVWF  71
11B6:  MOVLW  C5
11B8:  MOVWF  70
11BA:  MOVLW  27
11BC:  MOVWF  6F
11BE:  MOVLW  71
11C0:  MOVWF  6E
11C2:  MOVFF  59,75
11C6:  MOVFF  58,74
11CA:  MOVFF  57,73
11CE:  MOVFF  56,72
11D2:  CALL   063A
11D6:  BCF    FD8.1
11D8:  MOVLW  0A
11DA:  MOVWF  6D
11DC:  MOVLW  D7
11DE:  MOVWF  6C
11E0:  MOVLW  23
11E2:  MOVWF  6B
11E4:  MOVLW  78
11E6:  MOVWF  6A
11E8:  MOVFF  03,71
11EC:  MOVFF  02,70
11F0:  MOVFF  01,6F
11F4:  MOVFF  00,6E
11F8:  CALL   072C
11FC:  MOVFF  5D,71
1200:  MOVFF  5C,70
1204:  MOVFF  5B,6F
1208:  MOVFF  5A,6E
120C:  MOVFF  03,75
1210:  MOVFF  02,74
1214:  MOVFF  01,73
1218:  MOVFF  00,72
121C:  CALL   063A
1220:  MOVFF  00,5A
1224:  MOVFF  01,5B
1228:  MOVFF  02,5C
122C:  MOVFF  03,5D
1230:  BCF    FD8.1
1232:  MOVFF  03,6D
1236:  MOVFF  02,6C
123A:  MOVFF  01,6B
123E:  MOVFF  00,6A
1242:  MOVFF  45,71
1246:  MOVFF  44,70
124A:  MOVFF  43,6F
124E:  MOVFF  42,6E
1252:  CALL   072C
1256:  MOVFF  03,0B
125A:  MOVFF  02,0A
125E:  MOVFF  01,09
1262:  MOVFF  00,08
.................... } 
....................   
.................... //***** Function to measure & calculate SHT75 temp & RH ***** 
....................   
.................... void sht_rd (float & temp, float & truehumid) 
.................... { 
....................  int16 restemp, reshumid; 
....................  float realhumid; 
....................  restemp = 0; truehumid = 0; 
*
0FBC:  CLRF   3F
0FBE:  CLRF   3E
0FC0:  CLRF   0B
0FC2:  CLRF   0A
0FC4:  CLRF   09
0FC6:  CLRF   08
....................   
....................  restemp = measuretemp();    //measure temp 
0FC8:  GOTO   05AC
0FCC:  MOVFF  02,3F
0FD0:  MOVFF  01,3E
....................  reshumid = measurehumid();  //measure RH 
0FD4:  GOTO   05D8
0FD8:  MOVFF  02,41
0FDC:  MOVFF  01,40
.................... calculate_data (restemp, reshumid, temp, realhumid, truehumid);  //calculate temp & RH 
0FE0:  MOVFF  3F,4F
0FE4:  MOVFF  3E,4E
0FE8:  MOVFF  41,51
0FEC:  MOVFF  40,50
.................... } 
....................   
.................... //***** Function to initialise SHT75 on power-up ***** 
....................   
.................... void sht_init (void) 
.................... { 
....................  comreset();    //reset SHT75 
*
01B0:  BRA    018A
....................  delay_ms(20);  //delay for power-up 
01B2:  MOVLW  14
01B4:  MOVWF  4C
01B6:  RCALL  0070
.................... } 
01B8:  GOTO   0E66 (RETURN)
....................  
....................  
....................  
.................... #include "new_lcd.c" 
.................... // flex_lcd.c 
....................  
.................... // These pins are for the Microchip PicDem2-Plus board, 
.................... // which is what I used to test the driver.  Change these 
.................... // pins to fit your own board. 
....................  
.................... #define LCD_DB4   PIN_D4 
.................... #define LCD_DB5   PIN_D5 
.................... #define LCD_DB6   PIN_D6 
.................... #define LCD_DB7   PIN_D7 
....................  
.................... #define LCD_E     PIN_D0 
.................... #define LCD_RS    PIN_D1 
.................... //#define LCD_RW    0 
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... //#define USE_LCD_RW   1 
....................  
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... //======================================== 
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0x0C,//0xf,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
....................  
.................... /* 
.................... byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xC, 1,6}; 
....................  
.................... Value   Cursor  Blink 
.................... 0x0C     Off      Off 
.................... 0x0D     Off      On 
.................... 0x0E     On       Off 
.................... 0x0F     On       On 
....................  
.................... */ 
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
*
0098:  BTFSC  53.0
009A:  BRA    00A0
009C:  BCF    F8C.4
009E:  BRA    00A2
00A0:  BSF    F8C.4
00A2:  BCF    F95.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
00A4:  BTFSC  53.1
00A6:  BRA    00AC
00A8:  BCF    F8C.5
00AA:  BRA    00AE
00AC:  BSF    F8C.5
00AE:  BCF    F95.5
....................  output_bit(LCD_DB6, !!(nibble & 4)); 
00B0:  BTFSC  53.2
00B2:  BRA    00B8
00B4:  BCF    F8C.6
00B6:  BRA    00BA
00B8:  BSF    F8C.6
00BA:  BCF    F95.6
....................  output_bit(LCD_DB7, !!(nibble & 8)); 
00BC:  BTFSC  53.3
00BE:  BRA    00C4
00C0:  BCF    F8C.7
00C2:  BRA    00C6
00C4:  BSF    F8C.7
00C6:  BCF    F95.7
....................  
....................  delay_cycles(1); 
00C8:  NOP   
....................  output_high(LCD_E); 
00CA:  BCF    F95.0
00CC:  BSF    F8C.0
....................  delay_us(2); 
00CE:  BRA    00D0
....................  output_low(LCD_E); 
00D0:  BCF    F95.0
00D2:  BCF    F8C.0
.................... } 
00D4:  RETLW  00
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
....................  
.................... output_high(LCD_E); 
.................... delay_cycles(1); 
....................  
.................... retval_0 = input(LCD_DB4); 
.................... retval_1 = input(LCD_DB5); 
.................... retval_2 = input(LCD_DB6); 
.................... retval_3 = input(LCD_DB7); 
....................  
.................... output_low(LCD_E); 
....................  
.................... return(retval); 
.................... } 
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
.................... delay_cycles(1); 
....................  
.................... high = lcd_read_nibble(); 
....................  
.................... low = lcd_read_nibble(); 
....................  
.................... return( (high<<4) | low); 
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
00D6:  BCF    F95.1
00D8:  BCF    F8C.1
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
.................... #else 
.................... delay_us(60); 
00DA:  MOVLW  13
00DC:  MOVWF  00
00DE:  DECFSZ 00,F
00E0:  BRA    00DE
00E2:  BRA    00E4
.................... #endif 
....................  
.................... if(address) 
00E4:  MOVF   50,F
00E6:  BZ    00EE
....................    output_high(LCD_RS); 
00E8:  BCF    F95.1
00EA:  BSF    F8C.1
.................... else 
00EC:  BRA    00F2
....................    output_low(LCD_RS); 
00EE:  BCF    F95.1
00F0:  BCF    F8C.1
....................  
....................  delay_cycles(1); 
00F2:  NOP   
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... delay_cycles(1); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
00F4:  BCF    F95.0
00F6:  BCF    F8C.0
....................  
.................... lcd_send_nibble(n >> 4); 
00F8:  SWAPF  51,W
00FA:  MOVWF  52
00FC:  MOVLW  0F
00FE:  ANDWF  52,F
0100:  MOVFF  52,53
0104:  RCALL  0098
.................... lcd_send_nibble(n & 0xf); 
0106:  MOVF   51,W
0108:  ANDLW  0F
010A:  MOVWF  52
010C:  MOVWF  53
010E:  RCALL  0098
.................... } 
0110:  RETLW  00
....................  
.................... //---------------------------- 
....................  
....................  
.................... void lcd_setcursor_vb(short visible, short blink) { 
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink); 
.................... } 
....................  
....................  
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... output_low(LCD_RS); 
0112:  BCF    F95.1
0114:  BCF    F8C.1
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
0116:  BCF    F95.0
0118:  BCF    F8C.0
....................  
.................... delay_ms(15); 
011A:  MOVLW  0F
011C:  MOVWF  4C
011E:  RCALL  0070
....................  
.................... for(i=0 ;i < 3; i++) 
0120:  CLRF   3E
0122:  MOVF   3E,W
0124:  SUBLW  02
0126:  BNC   0138
....................    { 
....................     lcd_send_nibble(0x03); 
0128:  MOVLW  03
012A:  MOVWF  53
012C:  RCALL  0098
....................     delay_ms(5); 
012E:  MOVLW  05
0130:  MOVWF  4C
0132:  RCALL  0070
....................    } 
0134:  INCF   3E,F
0136:  BRA    0122
....................  
.................... lcd_send_nibble(0x02); 
0138:  MOVLW  02
013A:  MOVWF  53
013C:  RCALL  0098
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
013E:  CLRF   3E
0140:  MOVF   3E,W
0142:  SUBLW  03
0144:  BNC   015E
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0146:  CLRF   03
0148:  MOVF   3E,W
014A:  RCALL  0004
014C:  MOVWF  3F
014E:  CLRF   50
0150:  MOVWF  51
0152:  RCALL  00D6
....................  
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled.  One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 60 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
....................     #ifndef USE_LCD_RW 
....................     delay_ms(5); 
0154:  MOVLW  05
0156:  MOVWF  4C
0158:  RCALL  0070
....................     #endif 
....................    } 
015A:  INCF   3E,F
015C:  BRA    0140
....................  
.................... } 
015E:  RETLW  00
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
.................... if(y != 1) 
*
030E:  DECFSZ 4D,W
0310:  BRA    0314
0312:  BRA    031A
....................    address = lcd_line_two; 
0314:  MOVLW  40
0316:  MOVWF  4E
.................... else 
0318:  BRA    031C
....................    address=0; 
031A:  CLRF   4E
....................  
.................... address += x-1; 
031C:  MOVLW  01
031E:  SUBWF  4C,W
0320:  ADDWF  4E,F
.................... lcd_send_byte(0, 0x80 | address); 
0322:  MOVF   4E,W
0324:  IORLW  80
0326:  MOVWF  4F
0328:  CLRF   50
032A:  MOVWF  51
032C:  RCALL  00D6
.................... } 
032E:  RETLW  00
....................  
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
0330:  MOVF   4B,W
0332:  XORLW  0C
0334:  BZ    0340
0336:  XORLW  06
0338:  BZ    0350
033A:  XORLW  02
033C:  BZ    035C
033E:  BRA    0366
....................     case '\f': 
....................       lcd_send_byte(0,1); 
0340:  CLRF   50
0342:  MOVLW  01
0344:  MOVWF  51
0346:  RCALL  00D6
....................       delay_ms(2); 
0348:  MOVLW  02
034A:  MOVWF  4C
034C:  RCALL  0070
....................       break; 
034E:  BRA    0372
....................  
....................     case '\n': 
....................        lcd_gotoxy(1,2); 
0350:  MOVLW  01
0352:  MOVWF  4C
0354:  MOVLW  02
0356:  MOVWF  4D
0358:  RCALL  030E
....................        break; 
035A:  BRA    0372
....................  
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
035C:  CLRF   50
035E:  MOVLW  10
0360:  MOVWF  51
0362:  RCALL  00D6
....................        break; 
0364:  BRA    0372
....................  
....................     default: 
....................        lcd_send_byte(1,c); 
0366:  MOVLW  01
0368:  MOVWF  50
036A:  MOVFF  4B,51
036E:  RCALL  00D6
....................        break; 
0370:  BRA    0372
....................    } 
.................... } 
0372:  RETLW  00
....................  
.................... //------------------------------ 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7)); 
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(lcd_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
....................  
.................... //3x4 tuþ takýmý 
.................... #define sat1   pin_c0  
.................... #define sat2   pin_c1  
.................... #define sat3   pin_c2 
....................  
.................... #define sat4   pin_c3  
.................... #define sut1   pin_c4 
.................... #define sut2   pin_c5  
.................... #define sut3   pin_c6  
....................  
.................... // ýsýtýcý ve soðutucu 
.................... #define isitici   pin_b0  
.................... #define sogutucu  pin_b1 
....................  
.................... //sht11 algýlayýcý             
.................... #define sht_data_pin   PIN_b7//(Data pin veya input) 
.................... #define sht_clk_pin    PIN_b6 
....................  
.................... // sensor kontrol 
.................... #define ses_sensor   pin_b5  
....................  
.................... float temp=0,humid=0,sicaklik=0,nem=0; 
.................... int i=1, negatif=0, flag=0, derece=25, tus=99, pres = 99; 
....................  
....................                
.................... float Output, gZaman=1;  
.................... float lastError, pError=0, iError=0, dError=0;  
.................... float kp=1, ki=1, kd=1; 
....................          
.................... //fonksiyonlar 
.................... int keypad_oku() // Fonksiyon ismi 
.................... {    
.................... output_c(0x00); // D portu çýkýþý sýfýrlanýyor 
*
01DE:  CLRF   F94
01E0:  CLRF   F8B
....................  
....................    output_high(sat1);  
01E2:  BCF    F94.0
01E4:  BSF    F8B.0
....................       if (input(sut1))   
01E6:  BSF    F94.4
01E8:  BTFSS  F82.4
01EA:  BRA    01FC
....................          { delay_ms(20); tus=1;output_low(sat1);} 
01EC:  MOVLW  14
01EE:  MOVWF  4C
01F0:  RCALL  0070
01F2:  MOVLW  01
01F4:  MOVWF  18
01F6:  BCF    F94.0
01F8:  BCF    F8B.0
....................       else if (input(sut2))    
01FA:  BRA    022C
01FC:  BSF    F94.5
01FE:  BTFSS  F82.5
0200:  BRA    0212
....................          { delay_ms(20); tus=2;output_low(sat1);} 
0202:  MOVLW  14
0204:  MOVWF  4C
0206:  RCALL  0070
0208:  MOVLW  02
020A:  MOVWF  18
020C:  BCF    F94.0
020E:  BCF    F8B.0
....................       else if (input(sut3)) 
0210:  BRA    022C
0212:  BSF    F94.6
0214:  BTFSS  F82.6
0216:  BRA    0228
....................          { delay_ms(20); tus=3;output_low(sat1);} 
0218:  MOVLW  14
021A:  MOVWF  4C
021C:  RCALL  0070
021E:  MOVLW  03
0220:  MOVWF  18
0222:  BCF    F94.0
0224:  BCF    F8B.0
....................       else 
0226:  BRA    022C
....................         output_low(sat1); 
0228:  BCF    F94.0
022A:  BCF    F8B.0
....................     
....................    output_high(sat2); 
022C:  BCF    F94.1
022E:  BSF    F8B.1
....................       if (input(sut1))   
0230:  BSF    F94.4
0232:  BTFSS  F82.4
0234:  BRA    0246
....................          { delay_ms(20); tus=4;output_low(sat2);} 
0236:  MOVLW  14
0238:  MOVWF  4C
023A:  RCALL  0070
023C:  MOVLW  04
023E:  MOVWF  18
0240:  BCF    F94.1
0242:  BCF    F8B.1
....................       else if (input(sut2))  
0244:  BRA    0276
0246:  BSF    F94.5
0248:  BTFSS  F82.5
024A:  BRA    025C
....................          { delay_ms(20); tus=5;output_low(sat2);} 
024C:  MOVLW  14
024E:  MOVWF  4C
0250:  RCALL  0070
0252:  MOVLW  05
0254:  MOVWF  18
0256:  BCF    F94.1
0258:  BCF    F8B.1
....................       else if (input(sut3))   
025A:  BRA    0276
025C:  BSF    F94.6
025E:  BTFSS  F82.6
0260:  BRA    0272
....................          { delay_ms(20); tus=6;output_low(sat2);} 
0262:  MOVLW  14
0264:  MOVWF  4C
0266:  RCALL  0070
0268:  MOVLW  06
026A:  MOVWF  18
026C:  BCF    F94.1
026E:  BCF    F8B.1
....................       else 
0270:  BRA    0276
....................         output_low(sat2);  
0272:  BCF    F94.1
0274:  BCF    F8B.1
....................  
....................     output_high(sat3);  
0276:  BCF    F94.2
0278:  BSF    F8B.2
....................       if (input(sut1))    
027A:  BSF    F94.4
027C:  BTFSS  F82.4
027E:  BRA    0290
....................          { delay_ms(20); tus=7;output_low(sat3);} 
0280:  MOVLW  14
0282:  MOVWF  4C
0284:  RCALL  0070
0286:  MOVLW  07
0288:  MOVWF  18
028A:  BCF    F94.2
028C:  BCF    F8B.2
....................       else if (input(sut2))  
028E:  BRA    02C0
0290:  BSF    F94.5
0292:  BTFSS  F82.5
0294:  BRA    02A6
....................          { delay_ms(20); tus=8;output_low(sat3);} 
0296:  MOVLW  14
0298:  MOVWF  4C
029A:  RCALL  0070
029C:  MOVLW  08
029E:  MOVWF  18
02A0:  BCF    F94.2
02A2:  BCF    F8B.2
....................       else if (input(sut3))   
02A4:  BRA    02C0
02A6:  BSF    F94.6
02A8:  BTFSS  F82.6
02AA:  BRA    02BC
....................          { delay_ms(20); tus=9;output_low(sat3);} 
02AC:  MOVLW  14
02AE:  MOVWF  4C
02B0:  RCALL  0070
02B2:  MOVLW  09
02B4:  MOVWF  18
02B6:  BCF    F94.2
02B8:  BCF    F8B.2
....................       else 
02BA:  BRA    02C0
....................         output_low(sat3);  
02BC:  BCF    F94.2
02BE:  BCF    F8B.2
....................     
....................   output_high(sat4); 
02C0:  BCF    F94.3
02C2:  BSF    F8B.3
....................       if (input(sut1))   
02C4:  BSF    F94.4
02C6:  BTFSS  F82.4
02C8:  BRA    02DA
....................          { delay_ms(20); tus=10;output_low(sat4);} 
02CA:  MOVLW  14
02CC:  MOVWF  4C
02CE:  RCALL  0070
02D0:  MOVLW  0A
02D2:  MOVWF  18
02D4:  BCF    F94.3
02D6:  BCF    F8B.3
....................       else if (input(sut2))    
02D8:  BRA    0308
02DA:  BSF    F94.5
02DC:  BTFSS  F82.5
02DE:  BRA    02EE
....................          { delay_ms(20); tus=0;output_low(sat4);} 
02E0:  MOVLW  14
02E2:  MOVWF  4C
02E4:  RCALL  0070
02E6:  CLRF   18
02E8:  BCF    F94.3
02EA:  BCF    F8B.3
....................       else if (input(sut3))  
02EC:  BRA    0308
02EE:  BSF    F94.6
02F0:  BTFSS  F82.6
02F2:  BRA    0304
....................          { delay_ms(20); tus=19;output_low(sat4);} 
02F4:  MOVLW  14
02F6:  MOVWF  4C
02F8:  RCALL  0070
02FA:  MOVLW  13
02FC:  MOVWF  18
02FE:  BCF    F94.3
0300:  BCF    F8B.3
....................       else 
0302:  BRA    0308
....................         output_low(sat4); 
0304:  BCF    F94.3
0306:  BCF    F8B.3
....................  
....................    return tus;  
0308:  MOVFF  18,01
.................... } 
030C:  RETLW  00
....................  
.................... void allkeypadlow() 
.................... { 
....................    output_low(sat1); 
*
01BC:  BCF    F94.0
01BE:  BCF    F8B.0
....................    output_low(sat2); 
01C0:  BCF    F94.1
01C2:  BCF    F8B.1
....................    output_low(sat3); 
01C4:  BCF    F94.2
01C6:  BCF    F8B.2
....................    output_low(sat4); 
01C8:  BCF    F94.3
01CA:  BCF    F8B.3
....................    output_low(sut1); 
01CC:  BCF    F94.4
01CE:  BCF    F8B.4
....................    output_low(sut2); 
01D0:  BCF    F94.5
01D2:  BCF    F8B.5
....................    output_low(sut3); 
01D4:  BCF    F94.6
01D6:  BCF    F8B.6
....................    tus=99; 
01D8:  MOVLW  63
01DA:  MOVWF  18
.................... } 
01DC:  RETLW  00
....................  
....................  
.................... // ana program 
.................... void main() 
.................... { 
*
0DA8:  CLRF   FF8
0DAA:  BCF    FD0.7
0DAC:  CLRF   FEA
0DAE:  CLRF   FE9
0DB0:  CLRF   07
0DB2:  CLRF   06
0DB4:  CLRF   05
0DB6:  CLRF   04
0DB8:  CLRF   0B
0DBA:  CLRF   0A
0DBC:  CLRF   09
0DBE:  CLRF   08
0DC0:  CLRF   0F
0DC2:  CLRF   0E
0DC4:  CLRF   0D
0DC6:  CLRF   0C
0DC8:  CLRF   13
0DCA:  CLRF   12
0DCC:  CLRF   11
0DCE:  CLRF   10
0DD0:  MOVLW  01
0DD2:  MOVWF  14
0DD4:  CLRF   15
0DD6:  CLRF   16
0DD8:  MOVLW  19
0DDA:  MOVWF  17
0DDC:  MOVLW  63
0DDE:  MOVWF  18
0DE0:  MOVWF  19
0DE2:  CLRF   21
0DE4:  CLRF   20
0DE6:  CLRF   1F
0DE8:  MOVLW  7F
0DEA:  MOVWF  1E
0DEC:  CLRF   29
0DEE:  CLRF   28
0DF0:  CLRF   27
0DF2:  CLRF   26
0DF4:  CLRF   2D
0DF6:  CLRF   2C
0DF8:  CLRF   2B
0DFA:  CLRF   2A
0DFC:  CLRF   31
0DFE:  CLRF   30
0E00:  CLRF   2F
0E02:  CLRF   2E
0E04:  CLRF   35
0E06:  CLRF   34
0E08:  CLRF   33
0E0A:  MOVWF  32
0E0C:  CLRF   39
0E0E:  CLRF   38
0E10:  CLRF   37
0E12:  MOVWF  36
0E14:  CLRF   3D
0E16:  CLRF   3C
0E18:  CLRF   3B
0E1A:  MOVWF  3A
0E1C:  BSF    FC1.0
0E1E:  BSF    FC1.1
0E20:  BSF    FC1.2
0E22:  BCF    FC1.3
....................    setup_adc_ports(NO_ANALOGS); 
0E24:  BSF    FC1.0
0E26:  BSF    FC1.1
0E28:  BSF    FC1.2
0E2A:  BCF    FC1.3
....................    setup_adc(ADC_CLOCK_DIV_2); 
0E2C:  BCF    FC1.6
0E2E:  BCF    FC2.6
0E30:  BCF    FC2.7
0E32:  BCF    FC1.7
0E34:  BSF    FC2.0
....................    setup_psp(PSP_DISABLED); 
0E36:  BCF    F96.4
....................    setup_spi(SPI_SS_DISABLED); 
0E38:  BCF    FC6.5
0E3A:  BCF    F94.5
0E3C:  BSF    F94.4
0E3E:  BCF    F94.3
0E40:  MOVLW  01
0E42:  MOVWF  FC6
0E44:  MOVLW  00
0E46:  MOVWF  FC7
....................    setup_wdt(WDT_OFF); 
0E48:  BCF    FD1.0
....................    setup_timer_1(T1_DISABLED); 
0E4A:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
0E4C:  MOVWF  FCA
0E4E:  MOVLW  00
0E50:  MOVWF  FCB
....................    setup_ccp1(CCP_OFF); 
0E52:  BSF    F94.2
0E54:  CLRF   FBD
....................     
....................    lcd_init(); 
0E56:  CALL   0112
....................    delay_ms(100); 
0E5A:  MOVLW  64
0E5C:  MOVWF  4C
0E5E:  CALL   0070
....................    sht_init(); 
0E62:  GOTO   01B0
....................    delay_ms(100); 
0E66:  MOVLW  64
0E68:  MOVWF  4C
0E6A:  CALL   0070
....................   
....................   
....................    set_tris_a(0x00);   // A portu komple çýkýþ 
0E6E:  MOVLW  00
0E70:  MOVWF  F92
....................    set_tris_b(0x00); 
0E72:  MOVWF  F93
....................    set_tris_c(0x0f);    
0E74:  MOVLW  0F
0E76:  MOVWF  F94
....................    set_tris_d(0x00);    
0E78:  MOVLW  00
0E7A:  MOVWF  F95
....................  
....................    lcd_init();   // LCD hazýrlanýyor 
0E7C:  CALL   0112
....................  
....................    while(1) 
....................    {       
....................       allkeypadlow(); 
0E80:  CALL   01BC
....................       keypad_oku(); 
0E84:  CALL   01DE
....................       pres = tus; 
0E88:  MOVFF  18,19
....................       allkeypadlow(); 
0E8C:  CALL   01BC
....................        
....................       if(pres == 10) 
0E90:  MOVF   19,W
0E92:  SUBLW  0A
0E94:  BNZ   0EA2
....................       { 
....................           flag = 1; 
0E96:  MOVLW  01
0E98:  MOVWF  16
....................           printf(lcd_putc,"\f");  
0E9A:  MOVLW  0C
0E9C:  MOVWF  4B
0E9E:  CALL   0330
....................       }    
....................       while(flag==1) 
....................       {   
0EA2:  DECFSZ 16,W
0EA4:  BRA    0FBC
....................         lcd_gotoxy(1,1);      
0EA6:  MOVLW  01
0EA8:  MOVWF  4C
0EAA:  MOVWF  4D
0EAC:  CALL   030E
....................         printf(lcd_putc,"SIC gir"); 
0EB0:  MOVLW  18
0EB2:  MOVWF  FF6
0EB4:  MOVLW  00
0EB6:  MOVWF  FF7
0EB8:  GOTO   0374
....................         keypad_oku(); 
0EBC:  CALL   01DE
....................         pres = tus; 
0EC0:  MOVFF  18,19
....................         if(pres == 10 && i == 1) 
0EC4:  MOVF   19,W
0EC6:  SUBLW  0A
0EC8:  BNZ   0ED2
0ECA:  DECFSZ 14,W
0ECC:  BRA    0ED2
....................           pres = 99; 
0ECE:  MOVLW  63
0ED0:  MOVWF  19
....................         allkeypadlow();   
0ED2:  CALL   01BC
....................         if( pres >= 0 && pres <= 9) 
0ED6:  MOVF   19,W
0ED8:  SUBLW  09
0EDA:  BNC   0F1A
....................         { 
....................           lcd_gotoxy(i,2); 
0EDC:  MOVFF  14,4C
0EE0:  MOVLW  02
0EE2:  MOVWF  4D
0EE4:  CALL   030E
....................           if(i==1) 
0EE8:  DECFSZ 14,W
0EEA:  BRA    0EEE
....................             derece = 0; 
0EEC:  CLRF   17
....................           printf(lcd_putc,"%d",pres); 
0EEE:  MOVFF  19,3E
0EF2:  MOVLW  1F
0EF4:  MOVWF  3F
0EF6:  CALL   03BE
....................           delay_ms(1000); 
0EFA:  MOVLW  04
0EFC:  MOVWF  3E
0EFE:  MOVLW  FA
0F00:  MOVWF  4C
0F02:  CALL   0070
0F06:  DECFSZ 3E,F
0F08:  BRA    0EFE
....................           derece = (derece*10) + pres; 
0F0A:  MOVF   17,W
0F0C:  MULLW  0A
0F0E:  MOVF   FF3,W
0F10:  ADDWF  19,W
0F12:  MOVWF  17
....................           i += 1;     
0F14:  MOVLW  01
0F16:  ADDWF  14,F
....................          } 
....................          else if(pres == 19) 
0F18:  BRA    0FBA
0F1A:  MOVF   19,W
0F1C:  SUBLW  13
0F1E:  BNZ   0F66
....................          { 
....................           printf(lcd_putc,"\f%d derece \nayarlandi.",derece); 
0F20:  MOVLW  0C
0F22:  MOVWF  4B
0F24:  CALL   0330
0F28:  MOVFF  17,3E
0F2C:  MOVLW  1F
0F2E:  MOVWF  3F
0F30:  CALL   03BE
0F34:  MOVLW  23
0F36:  MOVWF  FF6
0F38:  MOVLW  00
0F3A:  MOVWF  FF7
0F3C:  MOVLW  13
0F3E:  MOVWF  3E
0F40:  CALL   0486
....................           flag = 0; 
0F44:  CLRF   16
....................           negatif = 0; 
0F46:  CLRF   15
....................           delay_ms(1000); 
0F48:  MOVLW  04
0F4A:  MOVWF  3E
0F4C:  MOVLW  FA
0F4E:  MOVWF  4C
0F50:  CALL   0070
0F54:  DECFSZ 3E,F
0F56:  BRA    0F4C
....................           i=1; 
0F58:  MOVLW  01
0F5A:  MOVWF  14
....................           printf(lcd_putc,"\f"); 
0F5C:  MOVLW  0C
0F5E:  MOVWF  4B
0F60:  CALL   0330
....................          } 
....................          else if(pres == 10) 
0F64:  BRA    0FBA
0F66:  MOVF   19,W
0F68:  SUBLW  0A
0F6A:  BNZ   0FBA
....................          { 
....................             printf(lcd_putc,"\f-%d derece \nayarlandi.",derece); 
0F6C:  MOVLW  0C
0F6E:  MOVWF  4B
0F70:  CALL   0330
0F74:  MOVLW  2D
0F76:  MOVWF  4B
0F78:  CALL   0330
0F7C:  MOVFF  17,3E
0F80:  MOVLW  1F
0F82:  MOVWF  3F
0F84:  CALL   03BE
0F88:  MOVLW  3C
0F8A:  MOVWF  FF6
0F8C:  MOVLW  00
0F8E:  MOVWF  FF7
0F90:  MOVLW  13
0F92:  MOVWF  3E
0F94:  CALL   0486
....................             flag = 0; 
0F98:  CLRF   16
....................             delay_ms(1000); 
0F9A:  MOVLW  04
0F9C:  MOVWF  3E
0F9E:  MOVLW  FA
0FA0:  MOVWF  4C
0FA2:  CALL   0070
0FA6:  DECFSZ 3E,F
0FA8:  BRA    0F9E
....................             negatif = 1; 
0FAA:  MOVLW  01
0FAC:  MOVWF  15
....................             i=1; 
0FAE:  MOVWF  14
....................             printf(lcd_putc,"\f"); 
0FB0:  MOVLW  0C
0FB2:  MOVWF  4B
0FB4:  CALL   0330
....................          } 
....................          else{;} 
0FB8:  BRA    0FBA
....................  
....................       } 
0FBA:  BRA    0EA2
....................  
....................       sht_rd (temp, humid); 
....................       sicaklik=(float)temp; 
*
1266:  MOVFF  07,0F
126A:  MOVFF  06,0E
126E:  MOVFF  05,0D
1272:  MOVFF  04,0C
....................       nem=(float)humid; 
1276:  MOVFF  0B,13
127A:  MOVFF  0A,12
127E:  MOVFF  09,11
1282:  MOVFF  08,10
....................       lcd_gotoxy(1,1); 
1286:  MOVLW  01
1288:  MOVWF  4C
128A:  MOVWF  4D
128C:  CALL   030E
....................       printf(lcd_putc,"SICAKLIK %2.2f C",sicaklik); 
1290:  MOVLW  50
1292:  MOVWF  FF6
1294:  MOVLW  00
1296:  MOVWF  FF7
1298:  MOVLW  09
129A:  MOVWF  3E
129C:  CALL   0486
12A0:  MOVLW  89
12A2:  MOVWF  FE9
12A4:  MOVFF  0F,41
12A8:  MOVFF  0E,40
12AC:  MOVFF  0D,3F
12B0:  MOVFF  0C,3E
12B4:  MOVLW  02
12B6:  MOVWF  42
12B8:  CALL   0A50
12BC:  MOVLW  20
12BE:  MOVWF  4B
12C0:  CALL   0330
12C4:  MOVLW  43
12C6:  MOVWF  4B
12C8:  CALL   0330
....................       lcd_gotoxy(1,2); 
12CC:  MOVLW  01
12CE:  MOVWF  4C
12D0:  MOVLW  02
12D2:  MOVWF  4D
12D4:  CALL   030E
....................       printf(lcd_putc,"NEM %2.2f RH",nem); 
12D8:  MOVLW  62
12DA:  MOVWF  FF6
12DC:  MOVLW  00
12DE:  MOVWF  FF7
12E0:  MOVLW  04
12E2:  MOVWF  3E
12E4:  CALL   0486
12E8:  MOVLW  89
12EA:  MOVWF  FE9
12EC:  MOVFF  13,41
12F0:  MOVFF  12,40
12F4:  MOVFF  11,3F
12F8:  MOVFF  10,3E
12FC:  MOVLW  02
12FE:  MOVWF  42
1300:  CALL   0A50
1304:  MOVLW  20
1306:  MOVWF  4B
1308:  CALL   0330
130C:  MOVLW  52
130E:  MOVWF  4B
1310:  CALL   0330
1314:  MOVLW  48
1316:  MOVWF  4B
1318:  CALL   0330
....................        
....................       //sensor kontrol 
....................       output_low(ses_sensor); 
131C:  BCF    F93.5
131E:  BCF    F8A.5
....................           delay_ms(1000); 
1320:  MOVLW  04
1322:  MOVWF  3E
1324:  MOVLW  FA
1326:  MOVWF  4C
1328:  CALL   0070
132C:  DECFSZ 3E,F
132E:  BRA    1324
....................       if(nem < 1) 
1330:  MOVFF  13,49
1334:  MOVFF  12,48
1338:  MOVFF  11,47
133C:  MOVFF  10,46
1340:  CLRF   4D
1342:  CLRF   4C
1344:  CLRF   4B
1346:  MOVLW  7F
1348:  MOVWF  4A
134A:  RCALL  0BD6
134C:  BNC   1362
....................       { 
....................        output_high(ses_sensor); 
134E:  BCF    F93.5
1350:  BSF    F8A.5
....................           delay_ms(1000); 
1352:  MOVLW  04
1354:  MOVWF  3E
1356:  MOVLW  FA
1358:  MOVWF  4C
135A:  CALL   0070
135E:  DECFSZ 3E,F
1360:  BRA    1356
....................       } 
....................        
....................       // pid 
....................         pError = derece - sicaklik; 
1362:  CLRF   67
1364:  MOVFF  17,66
1368:  CALL   0604
136C:  BSF    FD8.1
136E:  MOVFF  03,6D
1372:  MOVFF  02,6C
1376:  MOVFF  01,6B
137A:  MOVFF  00,6A
137E:  MOVFF  0F,71
1382:  MOVFF  0E,70
1386:  MOVFF  0D,6F
138A:  MOVFF  0C,6E
138E:  CALL   072C
1392:  MOVFF  03,29
1396:  MOVFF  02,28
139A:  MOVFF  01,27
139E:  MOVFF  00,26
....................         iError = (pError * gZaman) + iError; 
13A2:  MOVFF  29,71
13A6:  MOVFF  28,70
13AA:  MOVFF  27,6F
13AE:  MOVFF  26,6E
13B2:  MOVFF  21,75
13B6:  MOVFF  20,74
13BA:  MOVFF  1F,73
13BE:  MOVFF  1E,72
13C2:  CALL   063A
13C6:  MOVFF  00,3E
13CA:  MOVFF  01,3F
13CE:  MOVFF  02,40
13D2:  MOVFF  03,41
13D6:  BCF    FD8.1
13D8:  MOVFF  03,6D
13DC:  MOVFF  02,6C
13E0:  MOVFF  01,6B
13E4:  MOVFF  00,6A
13E8:  MOVFF  2D,71
13EC:  MOVFF  2C,70
13F0:  MOVFF  2B,6F
13F4:  MOVFF  2A,6E
13F8:  CALL   072C
13FC:  MOVFF  03,2D
1400:  MOVFF  02,2C
1404:  MOVFF  01,2B
1408:  MOVFF  00,2A
....................         dError = (pError - lastError) / gZaman; 
140C:  BSF    FD8.1
140E:  MOVFF  29,6D
1412:  MOVFF  28,6C
1416:  MOVFF  27,6B
141A:  MOVFF  26,6A
141E:  MOVFF  25,71
1422:  MOVFF  24,70
1426:  MOVFF  23,6F
142A:  MOVFF  22,6E
142E:  CALL   072C
1432:  MOVFF  00,3E
1436:  MOVFF  01,3F
143A:  MOVFF  02,40
143E:  MOVFF  03,41
1442:  MOVFF  03,45
1446:  MOVFF  02,44
144A:  MOVFF  01,43
144E:  MOVFF  00,42
1452:  MOVFF  21,49
1456:  MOVFF  20,48
145A:  MOVFF  1F,47
145E:  MOVFF  1E,46
1462:  GOTO   0C4C
1466:  MOVFF  03,31
146A:  MOVFF  02,30
146E:  MOVFF  01,2F
1472:  MOVFF  00,2E
....................                            
....................      Output = kp * pError + ki * iError + kd * dError; 
1476:  MOVFF  35,71
147A:  MOVFF  34,70
147E:  MOVFF  33,6F
1482:  MOVFF  32,6E
1486:  MOVFF  29,75
148A:  MOVFF  28,74
148E:  MOVFF  27,73
1492:  MOVFF  26,72
1496:  CALL   063A
149A:  MOVFF  00,3E
149E:  MOVFF  01,3F
14A2:  MOVFF  02,40
14A6:  MOVFF  03,41
14AA:  MOVFF  39,71
14AE:  MOVFF  38,70
14B2:  MOVFF  37,6F
14B6:  MOVFF  36,6E
14BA:  MOVFF  2D,75
14BE:  MOVFF  2C,74
14C2:  MOVFF  2B,73
14C6:  MOVFF  2A,72
14CA:  CALL   063A
14CE:  BCF    FD8.1
14D0:  MOVFF  41,6D
14D4:  MOVFF  40,6C
14D8:  MOVFF  3F,6B
14DC:  MOVFF  3E,6A
14E0:  MOVFF  03,71
14E4:  MOVFF  02,70
14E8:  MOVFF  01,6F
14EC:  MOVFF  00,6E
14F0:  CALL   072C
14F4:  MOVFF  00,3E
14F8:  MOVFF  01,3F
14FC:  MOVFF  02,40
1500:  MOVFF  03,41
1504:  MOVFF  3D,71
1508:  MOVFF  3C,70
150C:  MOVFF  3B,6F
1510:  MOVFF  3A,6E
1514:  MOVFF  31,75
1518:  MOVFF  30,74
151C:  MOVFF  2F,73
1520:  MOVFF  2E,72
1524:  CALL   063A
1528:  BCF    FD8.1
152A:  MOVFF  41,6D
152E:  MOVFF  40,6C
1532:  MOVFF  3F,6B
1536:  MOVFF  3E,6A
153A:  MOVFF  03,71
153E:  MOVFF  02,70
1542:  MOVFF  01,6F
1546:  MOVFF  00,6E
154A:  CALL   072C
154E:  MOVFF  03,1D
1552:  MOVFF  02,1C
1556:  MOVFF  01,1B
155A:  MOVFF  00,1A
....................    
....................         lastError = pError; 
155E:  MOVFF  29,25
1562:  MOVFF  28,24
1566:  MOVFF  27,23
156A:  MOVFF  26,22
....................         gZaman = gZaman + 500; 
156E:  BCF    FD8.1
1570:  MOVFF  21,6D
1574:  MOVFF  20,6C
1578:  MOVFF  1F,6B
157C:  MOVFF  1E,6A
1580:  CLRF   71
1582:  CLRF   70
1584:  MOVLW  7A
1586:  MOVWF  6F
1588:  MOVLW  87
158A:  MOVWF  6E
158C:  CALL   072C
1590:  MOVFF  03,21
1594:  MOVFF  02,20
1598:  MOVFF  01,1F
159C:  MOVFF  00,1E
....................        
....................       if(negatif == 1 && derece != 0) 
15A0:  DECFSZ 15,W
15A2:  BRA    15C2
15A4:  MOVF   17,F
15A6:  BZ    15C2
....................       { 
....................        output_low(isitici); 
15A8:  BCF    F93.0
15AA:  BCF    F8A.0
....................        output_high(sogutucu); 
15AC:  BCF    F93.1
15AE:  BSF    F8A.1
....................           delay_ms(1000); 
15B0:  MOVLW  04
15B2:  MOVWF  3E
15B4:  MOVLW  FA
15B6:  MOVWF  4C
15B8:  CALL   0070
15BC:  DECFSZ 3E,F
15BE:  BRA    15B4
....................       } 
....................       else if(derece >= sicaklik-0.5 && derece <= sicaklik+0.5) 
15C0:  BRA    1732
15C2:  BSF    FD8.1
15C4:  MOVFF  0F,6D
15C8:  MOVFF  0E,6C
15CC:  MOVFF  0D,6B
15D0:  MOVFF  0C,6A
15D4:  CLRF   71
15D6:  CLRF   70
15D8:  CLRF   6F
15DA:  MOVLW  7E
15DC:  MOVWF  6E
15DE:  CALL   072C
15E2:  MOVFF  00,3E
15E6:  MOVFF  01,3F
15EA:  MOVFF  02,40
15EE:  MOVFF  03,41
15F2:  CLRF   67
15F4:  MOVFF  17,66
15F8:  CALL   0604
15FC:  MOVFF  41,49
1600:  MOVFF  40,48
1604:  MOVFF  3F,47
1608:  MOVFF  3E,46
160C:  MOVFF  03,4D
1610:  MOVFF  02,4C
1614:  MOVFF  01,4B
1618:  MOVFF  00,4A
161C:  CALL   0BD6
1620:  BC    1624
1622:  BNZ   16A0
1624:  BCF    FD8.1
1626:  MOVFF  0F,6D
162A:  MOVFF  0E,6C
162E:  MOVFF  0D,6B
1632:  MOVFF  0C,6A
1636:  CLRF   71
1638:  CLRF   70
163A:  CLRF   6F
163C:  MOVLW  7E
163E:  MOVWF  6E
1640:  CALL   072C
1644:  MOVFF  00,42
1648:  MOVFF  01,43
164C:  MOVFF  02,44
1650:  MOVFF  03,45
1654:  CLRF   67
1656:  MOVFF  17,66
165A:  CALL   0604
165E:  MOVFF  03,49
1662:  MOVFF  02,48
1666:  MOVFF  01,47
166A:  MOVFF  00,46
166E:  MOVFF  45,4D
1672:  MOVFF  44,4C
1676:  MOVFF  43,4B
167A:  MOVFF  42,4A
167E:  CALL   0BD6
1682:  BC    1686
1684:  BNZ   16A0
....................       { 
....................        output_low(isitici); 
1686:  BCF    F93.0
1688:  BCF    F8A.0
....................        output_low(sogutucu); 
168A:  BCF    F93.1
168C:  BCF    F8A.1
....................           delay_ms(1000); 
168E:  MOVLW  04
1690:  MOVWF  3E
1692:  MOVLW  FA
1694:  MOVWF  4C
1696:  CALL   0070
169A:  DECFSZ 3E,F
169C:  BRA    1692
....................       }   
....................       else if(derece > sicaklik) 
169E:  BRA    1732
16A0:  CLRF   67
16A2:  MOVFF  17,66
16A6:  CALL   0604
16AA:  MOVFF  0F,49
16AE:  MOVFF  0E,48
16B2:  MOVFF  0D,47
16B6:  MOVFF  0C,46
16BA:  MOVFF  03,4D
16BE:  MOVFF  02,4C
16C2:  MOVFF  01,4B
16C6:  MOVFF  00,4A
16CA:  CALL   0BD6
16CE:  BNC   16EA
....................       { 
....................        output_high(isitici); 
16D0:  BCF    F93.0
16D2:  BSF    F8A.0
....................        output_low(sogutucu);   
16D4:  BCF    F93.1
16D6:  BCF    F8A.1
....................           delay_ms(1000);    
16D8:  MOVLW  04
16DA:  MOVWF  3E
16DC:  MOVLW  FA
16DE:  MOVWF  4C
16E0:  CALL   0070
16E4:  DECFSZ 3E,F
16E6:  BRA    16DC
....................       } 
....................       else if(derece < sicaklik) 
16E8:  BRA    1732
16EA:  CLRF   67
16EC:  MOVFF  17,66
16F0:  CALL   0604
16F4:  MOVFF  03,49
16F8:  MOVFF  02,48
16FC:  MOVFF  01,47
1700:  MOVFF  00,46
1704:  MOVFF  0F,4D
1708:  MOVFF  0E,4C
170C:  MOVFF  0D,4B
1710:  MOVFF  0C,4A
1714:  CALL   0BD6
1718:  BNC   1732
....................       { 
....................        output_low(isitici); 
171A:  BCF    F93.0
171C:  BCF    F8A.0
....................        output_high(sogutucu);   
171E:  BCF    F93.1
1720:  BSF    F8A.1
....................           delay_ms(1000); 
1722:  MOVLW  04
1724:  MOVWF  3E
1726:  MOVLW  FA
1728:  MOVWF  4C
172A:  CALL   0070
172E:  DECFSZ 3E,F
1730:  BRA    1726
....................       } 
....................        
....................    } 
1732:  GOTO   0E80
....................  
.................... } 
1736:  SLEEP 

Configuration Fuses:
   Word  1: 2100   XT NOOSCSEN
   Word  2: 0E0D   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 0100   CCP2C1
   Word  4: 0080   NOSTVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
